# Vue3-template

> 项目采用的技术栈是 vue3+typescript+pinia

## 1.项目初始化

### 创建项目

```bash
pnpm create vite vue-template --template vue-ts
```

## 2.基础配置

### 2.1 eslint 配置

```bash
npx eslint --init
```

**校验语法错误**

```bash
? How would you like to use ESLint? ...
 To check syntax only
> To check syntax and find problems
 To check syntax, find problems, and enforce code style
```

**js-module**

```bash
? What type of modules does your project use? …
❯ JavaScript modules (import/export)
  CommonJS (require/exports)
  None of these
```

**采用的技术栈**

```bash
? Which framework does your project use? …
  React
❯ Vue.js
  None of these
```

**是否使用 typescript**

```bash
? Does your project use TypeScript? › No / Yes
```

**在哪里运行，两个都选因为单元测试是跑在 node 环境中的**

```bash
? Where does your code run? …  (Press <space> to select, <a> to toggle all, <i> to invert selection)
✔ Browser
✔ Node
```

**配置文件以什么文件类型显示**

```bash
? What format do you want your config file to be in? …
❯ JavaScript
  YAML
  JSON
```

**用 pnpm 安装**

```bash
✔ Would you like to install them now? · No / Yes
? Which package manager do you want to use? …
  npm
  yarn
❯ pnpm
```

**.eslintrc 文件说明**

```js
module.exports = {
  env: {
    // 针对哪些环境语法
    browser: true,
    es2021: true,
    node: true,
  },
  extends: [
    // 推荐的规则直接拿来用
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:vue/vue3-essential",
  ],
  parserOptions: {
    ecmaVersion: "latest",
    parser: "@typescript-eslint/parser", // 解析.ts文件
    sourceType: "module",
  },
  plugins: ["@typescript-eslint", "vue"],
  rules: {
    // 自定义的规则
  },
};
```

**创建.eslintignore 文件**

```js
node_modules
dist
*.css
*.jpg
*.jpeg
*.png
*.gif
*.d.ts
```

**在 package.json 中添加下面代码**

```js
"lint": "eslint --fix --ext .ts,.tsx,.vue src --quiet"
```

### 2.2 prettier 配置

**在 eslint 中配置 prettier**

```bash
pnpm install prettier eslint-plugin-prettier @vue/eslint-config-prettier -D
```

**在 eslint 中配置 prettier**

```js
module.exports = {
  env: {
    // 针对哪些环境语法
    browser: true,
    es2021: true,
    node: true,
  },
  extends: [
    // 推荐的规则直接拿来用
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:vue/vue3-essential",
    "@vue/prettier",
  ],
  parserOptions: {
    ecmaVersion: "latest",
    parser: "@typescript-eslint/parser", // 解析.ts文件
    sourceType: "module",
  },
  plugins: ["@typescript-eslint", "vue"],
  rules: {
    // 自定义的规则
    "prettier/prettier": [
      "error",
      {
        singleQuote: false, // 使用单引号
        semi: false, // 末尾添加分号
        tabWidth: 2,
        trailingComma: "none",
        useTabs: false,
        endOfLine: "auto",
      },
    ],
  },
};
```

**创建.prettierrc.js 文件**

```js
module.exports = {
  singleQuote: false, // 使⽤单引号
  semi: false, // 末尾添加分号
  tabWidth: 2,
  trailingComma: "none",
  useTabs: false,
  endOfLine: "auto",
};
```

**EditorConfig for VS Code**

> 安装 EditorConfig for VS Code 插件，新建.editorconfig 文件

```js
root = true
[*]
charset = utf-8
indent_style = space
indent_size = 2
end_of_line = lf
```

### 2.3 husky 配置 - 这个暂时不安装

```bash
npm pkg set scripts.prepare="husky install"
```

::: info

```js
// 出现这个问题 是因为冒号后面没有加空格
⧗   input: feat:初始化项目
✖   subject may not be empty [subject-empty]
✖   type may not be empty [type-empty]
```

```js
// 这个权限问题没有解决
.husky/commit-msg: line 5: .git/COMMIT_EDITMSG: Permission denied
```

:::

### 2.4 集成 vue-router

```bash
pnpm install vue-router
```

**关闭组件命名警告**

```js
rules: {
// 我们自定义的规则写在这里
"vue/multi-word-component-names": "off",
"prettier/prettier": [
    ...
 ]
}
```

**在 src 下创建 router 目录，添加 index.ts 文件**

```js
import { createRouter, createWebHistory } from "vue-router";

export default createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: "/home",
      component: () => import("../Home.vue"),
    },
    {
      path: "/about",
      component: () => import("../About.vue"),
    },
  ],
});
```

**在 main 中引入**

```js
<template>
  <router-link to="/home">Home</router-link>
  <router-link to="/about">About</router-link>
  <router-view></router-view>
</template>
```

### 2.5 设置路径别名

- 在 vite.config.js 中添加 resolve

```js
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import path from "path";

// https://vitejs.dev/config/
export default defineConfig({
  resolve: {
    alias: [
      {
        find: "@",
        replacement: path.resolve(__dirname, "src"),
      },
    ],
  },
  plugins: [vue()],
});
```

::: info
如果找不到 path 的类型声明文件

```bash
pnpm install @types/node -D
```

:::

- 在 tsconfig.js 中配置

```js
{
  "compilerOptions": {
    ...
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  ...
}
```

### 2.5 集成 pinia

**安装**

```bash
pnpm install pinia
```

**在 src 下创建 stores 目录，并创建 counter.ts**

```ts
import { defineStore } from "pinia";
import { ref } from "vue";

export const useCounterStore = defineStore("counter", () => {
  const count = ref(0);
  const increment = () => {
    count.value++;
  };
  return { count, increment };
});
```

**在 src 下的 components 中创建 Counter.vue**

```vue
<template>
  <div>
    <button @click="counter.increment">增加</button>
    <div>{{ counter.count }}</div>
  </div>
</template>

<script setup lang="ts">
import { useCounterStore } from "@/stores/counter";

const counter = useCounterStore();
</script>
```

**在 App 组件中引入 Counter 组件**

```vue
<template>
  <router-link to="/home">Home</router-link>
  <router-link to="/About">About</router-link>
  <router-view></router-view>
  <Counter></Counter>
</template>
```

**在 main.ts 中引入 createPinia**

```ts
import { createPinia } from "pinia";

createApp(App).use(router).use(createPinia()).mount("#app");
```

### 2.5 集成 Element Plus

**安装**

```bash
pnpm install element-plus
```

**main 中配置**

```ts
import { createApp } from "vue";
import App from "./App.vue";
import router from "./router/index";
import { createPinia } from "pinia";
+ import ElementPlus from "element-plus"; // 这里我们直接全量引入
+ import "element-plus/dist/index.css";
const app = createApp(App);
+ app.use(ElementPlus);
app.use(router);
app.use(createPinia());
app.mount("#app");
```

**Volar 支持**

```json
{
  "compilerOptions": {
    // ...
    "types": ["element-plus/global"]
  }
}
```

## 3.首页布局

### 3.1 创建 layout 布局组件

src 下创建 layout/index.vue

```vue
<template>
  <div class="app-wrapper">
    <div class="sidebar-container">sidebar</div>
    <div class="main-container">
      <div class="header">
        <div class="navbar">navbar</div>
        <div class="tags-view">tagsview</div>
      </div>
      <div class="app-main">
        <h2>app main</h2>
        <router-view></router-view>
      </div>
    </div>
  </div>
</template>
```

### 3.2 创建 Dashboard 页面

src/views/dashboard/index.vue

```vue
<template>
  <div>
    <h1>Dashboard page</h1>
  </div>
</template>
```

### 3.3 配置路由

src/router/index.ts

```ts
import { RouteRecordRaw, createRouter, createWebHistory } from "vue-router";
import Layout from "@/layout/index.vue";

const routes: Array<RouteRecordRaw> = [
  {
    path: "/",
    component: Layout,
    redirect: "/dashboard",
    children: [
      {
        path: "dashboard",
        name: "Dashboard",
        component: () =>
          import(
            /* WebpackChunkName: dashboard */ "@/views/dashboard/index.vue"
          ),
        meta: {
          title: "Dashboard",
        },
      },
    ],
  },
];

export default createRouter({
  history: createWebHistory(),
  routes,
});
```

> 在 router 目录下 typings.d.ts 针对 RouteMeta 进行类型补充

src/router/typings.d.ts

```ts
import "vue-router";
declare module "vue-router" {
  interface RouteMeta {
    title?: string; // 路由菜单title
    icon?: string; // 路由菜单icon
    hidden?: boolean; // 菜单栏不显示
    // 路由是否缓存 没有这个属性或false都会缓存 true不缓存
    noCache?: boolean;
    activeMenu?: string; // 指定菜单激活
    breadcrumb?: boolean; // 该路由是否显示面包屑
    affix?: boolean; // 固定显示在tagsView中
    alwaysShow?: boolean; // 菜单是否一直显示根路由
  }
}
```

### 3.3 styles 样式文件

**安装 sass**

```bash
pnpm install sass -D
```

src\styles\variables.module.scss

```scss
// base color
$blue: #324157;
$light-blue: #3a71a8;
$red: #c03639;
$pink: #e65d6e;
$green: #30b08f;
$tiffany: #4ab7bd;
$yellow: #fec171;
$panGreen: #30b08f;

// sidebar
$menuText: #bfcbd9;
$menuActiveText: #409eff;
$subMenuActiveText: #f4f4f5;
$menuBg: #304156;
$menuHover: #263445;
$subMenuBg: #1f2d3d;
$subMenuHover: #001528;
$sideBarWidth: 210px;
// 导出变量提供给js来使用
:export {
  menuText: $menuText;
  menuActiveText: $menuActiveText;
  subMenuActiveText: $subMenuActiveText;
  menuBg: $menuBg;
  menuHover: $menuHover;
  subMenuBg: $subMenuBg;
  subMenuHover: $subMenuHover;
  sideBarWidth: $sideBarWidth;
}
```

src\styles\sidebar.scss

```scss
#app {
  .sidebar-container {
    width: $sideBarWidth !important;
    height: 100%;
    background-color: $yellow;
  }
}
```

src\styles\index.scss

```scss
@import "./variables.module.scss";
@import "./sidebar.scss";
html {
  height: 100%;
  box-sizing: border-box;
}

body {
  height: 100%;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
  font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB, Microsoft
      YaHei, Arial, sans-serif;
}
#app {
  height: 100%;
}
```

**样式重置**

安装

```bash
pnpm install normalize.css
```

**main.ts 中引入**

```ts
import { createApp } from "vue";
import App from "./App.vue";
import router from "./router/index";
import { createPinia } from "pinia";
import ElementPlus from "element-plus";
import "element-plus/dist/index.css";
// 初始化css，重置css默认样式
import "normalize.css/normalize.css";
// 全局css
import "@/styles/index.scss";
const app = createApp(App);
app.use(createPinia());
app.use(router);
app.use(ElementPlus);
app.mount("#app");
```

### 3.4 完善 layout 样式

```vue
<style lang="scss" scoped>
.app-wrapper {
  display: flex;
  width: 100%;
  height: 100%;
  .main-container {
    flex: 1;
    display: flex;

    flex-direction: column;
    .header {
      background: cyan;
      .navbar {
        height: 50px;
        background: #1890ff;
      }
      .tags-view {
        height: 34px;
        background: #12efff;
      }
    }
    .app-main {
      /* main = 100% - navbar + tagsview */
      min-height: calc(100vh - 84px);
      background: red;
    }
  }
}
</style>
```

## 4.SvgIcon 组件开发

### 4.1 准备 svg 文件

### 4.2 配置 [vite-plugin-svg-icons](https://github.com/vbenjs/vite-plugin-svg-icons)

> 用来根据导入的 svg 文件自动生成 symbol 标签并插入 html,生成 svg 雪碧图。

```bash
pnpm install vite-plugin-svg-icons -D
```

修改 vite.config.js

```js
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import path from "path";
import { createSvgIconsPlugin } from "vite-plugin-svg-icons";

// https://vitejs.dev/config/
export default defineConfig({
  resolve: {
    alias: [
      {
        find: "@",
        replacement: path.resolve(__dirname, "src"),
      },
    ],
  },
  plugins: [
    vue(),
    createSvgIconsPlugin({
      iconDirs: [path.resolve(process.cwd(), "src/icons/svg")], // icon存放的目录
      symbolId: "icon-[name]", // symbol的id
      inject: "body-last", // 插入的位置
      customDomId: "__svg__icons__dom__", // svg的id
    }),
  ],
});
```

**在 src/main.ts 内引入注册脚本**

> import 'virtual:svg-icons-register'

### 4.3 开发 svg icon 组件

src/components/SvgIcon/index.vue

```vue
<template>
  <!-- 如果iconClass是带协议的图标链接 则通过style属性方式渲染-->
  <div
    class="svg-icon svg-external-icon"
    v-if="isExt"
    :style="styleExternalIcon"
    v-bind="$attrs"
  ></div>
  <!-- SVG icon 通过名称使用 -->
  <svg v-else :class="svgClass" aria-hidden="true" v-bind="$attrs">
    <!--
SVG中的use元素可以调用其他SVG文件的元素，<use xlink:href="#symbolId">
</use>
-->
    <use :xlink:href="iconName" />
  </svg>
</template>
<script setup lang="ts">
import { isExternal } from "@/utils/validate";
import { computed } from "vue";
const props = defineProps<{ iconClass: string; className?: string }>();
// 是否是带协议的图片链接
const isExt = computed(() => isExternal(props.iconClass || ""));
// 拼接成symbolId 在loader配置中指定了symbolId格式 icon-图标名称
const iconName = computed(() => `#icon-${props.iconClass}`);
// 添加类名 props.className外部传入自定义类名
const svgClass = computed(() =>
  props.className ? `svg-icon ${props.className}` : "svg-icon"
);
// 如果iconClass是带协议的图标链接 则通过style css属性方式渲染
const styleExternalIcon = computed(() => ({
  mask: `url(${props.iconClass}) no-repeat 50% 50%`,
  "-webkit-mask": `url(${props.iconClass}) no-repeat 50% 50%`,
}));
</script>
<style scoped>
.svg-icon {
  width: 1em;
  height: 1em;
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}
.svg-external-icon {
  background-color: currentColor;
  mask-size: cover !important;
  display: inline-block;
}
</style>
```

src/utils/validate.ts

```ts
export const isExternal = (path: string): boolean => {
  return /^(https?:|mailto:|tel:)/.test(path);
};
```

### 4.4 全局注册 svg

src/icons/index.ts 全局注册 svg icon 组件入口

```ts
import { App } from "vue";
import SvgIcon from "@/components/SvgIcon/index.vue";
export default (app: App) => {
  // 全局注册svg-icon组件
  app.component("svg-icon", SvgIcon);
};
```

### 4.6 main.ts 通过 use 安装 icon 组件

```ts
import { createApp } from "vue";
import App from "./App.vue";
import router from "./router/index";
import { createPinia } from "pinia";
import ElementPlus from "element-plus";
import "element-plus/dist/index.css";
// 初始化css，重置css默认样式
import "normalize.css/normalize.css";
// 全局css
import "@/styles/index.scss";

// 引入icon插件
import initSvgIcon from "@/icons/index";
import "virtual:svg-icons-register";

const app = createApp(App);
app.use(createPinia());
app.use(router);
app.use(ElementPlus);
app.use(initSvgIcon);
app.mount("#app");
```

### 4.7 实验效果

src/views/dashboard/index.vue

```vue
<template>
  <div>
    <h1>Dashboard page</h1>
    <svg-icon icon-class="bug"></svg-icon>
    <!-- icon-class svg图标名称 class-name 额外的自定义类名 @click绑定事件 -->
    <svg-icon
      icon-class="404"
      class-name="custom-class"
      @click="sayHi"
    ></svg-icon>
  </div>
</template>
<script setup lang="ts">
const sayHi = () => {
  alert("hi svg");
};
</script>
<style lang="scss">
.custom-class {
  // 自定义样式404
  font-size: 200px;
  color: green;
}
</style>
```

### 4.8 Svg 优化

> svgo 是 svg 压缩处理优化工具。我们很多网上下载或者 Sketch 导出的 svg 会有很多冗余
> 无用的信息，大大的增加了 svg 的尺寸，我们可以使用 svgo 对它进行优化。

安装

```bash
pnpm install svgo -D
```

src/icons/svgo.config.cjs

```js
module.exports = {
  plugins: [
    "preset-default", // 默认插件配置
    {
      name: "removeAttrs",
      params: {
        attrs: "(fill|stroke)",
      },
    },
  ],
};
```

package.json 添加 npm scripts

```json
{
  "scripts": {
    "svgo": "svgo -f src/icons/svg --config=src/icons/svgo.config.cjs"
  }
}
```

```js
-  plugins: [vue()]
+  plugins: [
+    vue(),
+    createSvgIconsPlugin({
+      iconDirs: [path.resolve(process.cwd(), 'src/icons/svg')], // icon存放的目录
+      symbolId: 'icon-[name]', // symbol的id
+      inject: 'body-last', // 插入的位置
+      customDomId: '__svg__icons__dom__' // svg的id
+    })
+  ]
```

## 5. 组件库按需导入

### 5.1 按需导入

需要两个插件

> pnpm install -D unplugin-vue-components unplugin-auto-import

vite.config.js

```js
// 自动导入
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

import ElementPlus from 'unplugin-element-plus/vite'

// https://vitejs.dev/config/
export default defineConfig({
  ...
  plugins: [
    ...
    // 自动导入
    AutoImport({
      imports: ['vue', 'vue-router'], // 顺便自动导入 vue vue-router
      resolvers: [ElementPlusResolver()],
      eslintrc: { enabled: false },
      dts: 'src/auto-import.d.ts' // 生成的全局变量放到此目录下
    }),
    Components({
      // 默认只针对src/components目录实现自动导入
      dirs: ['src/components', 'src/layout/components'], // 后面布局组件也有相关的组件期望自动导入
      dts: 'src/components.d.ts',
      resolvers: [ElementPlusResolver()] // 生成的组件的类型放到这里
    }),
  ]
})
```

### 5.2 弹框类型的组件挂载到 app 上

src/plugins/element.ts

```ts
import { App } from "vue";
import { ElMessage, ElNotification, ElMessageBox } from "element-plus";
// 默认自动导入组件插件，只会解析在模板中使用的组件，所以这里需要导入样式
// 这里的样式也可以做到按需导入
import "element-plus/theme-chalk/el-message.css";
import "element-plus/theme-chalk/el-notification.css";
import "element-plus/theme-chalk/el-message-box.css";
export default (app: App): void => {
  // 按需导入组件列表
  // Vue.prototype 替换为 config.globalProperties
  // 文档说明 https://v3.cn.vuejs.org/guide/migration/global-api.html#vueprototype-%E6%9B%BF%E6%8D%A2%E4%B8%BA-config-globalproperties
  app.config.globalProperties.$message = ElMessage;
  app.config.globalProperties.$notify = ElNotification;
  app.config.globalProperties.$confirm = ElMessageBox.confirm;
  app.config.globalProperties.$alert = ElMessageBox.alert;
  app.config.globalProperties.$prompt = ElMessageBox.prompt;
};
```

src/main.ts

```ts
...
// 注册element-plus
import installElementPlus from './plugins/element'

...
app.use(installElementPlus)

```

### 5.3 按需导入样式

vite.config.js

```js
import ElementPlus from 'unplugin-element-plus/vite'

export default defineConfig({
  ...
  plugins: [
    ...
    ElementPlus({})
  ]
})

```

注释掉 src/plugins/element.ts

```ts
import { App } from "vue";
import { ElMessage, ElNotification, ElMessageBox } from "element-plus";
// 默认自动导入组件插件，只会解析在模板中使用的组件，所以这里需要导入样式
// 这里的样式也可以做到按需导入
// import 'element-plus/theme-chalk/el-message.css'
// import 'element-plus/theme-chalk/el-notification.css'
// import 'element-plus/theme-chalk/el-message-box.css'
```

### 5.4 组件中使用

```vue
<template>
  <div>
    <h1>Dashboard page</h1>
    <svg-icon icon-class="bug"></svg-icon>
    <!-- icon-class svg图标名称 class-name 额外的自定义类名 @click绑定事件 -->
    <svg-icon
      icon-class="404"
      class-name="custom-class"
      @click="sayHi"
    ></svg-icon>
  </div>
</template>
<script setup lang="ts">
// import { getCurrentInstance } from 'vue'
const { proxy } = getCurrentInstance()!;
const sayHi = () => {
  proxy?.$message.success("恭喜你，这是一条成功消息");
};
</script>
<style lang="scss">
.custom-class {
  // 自定义样式404
  font-size: 200px;
  color: green;
}
</style>
```

### 5.5 解决 eslint 报错问题

getCurrentInstance 不存在

vite.config.js

```js
 AutoImport({
    imports: ['vue', 'vue-router'], // 顺便自动导入 vue vue-router
    resolvers: [ElementPlusResolver()],
    eslintrc: { enabled: false }, // 改成true生成一次后禁用即可
    dts: 'src/auto-import.d.ts' // 生成的全局变量放到此目录下
  }),
```

.eslintrc.cjs

```cjs
module.exports = {
  ...
  extends: [
    // 推荐的规则直接拿来用
    ...
    './.eslintrc-auto-import.json'
  ],
  ...
  rules: {
    // 自定义的规则
    ...
    '@typescript-eslint/no-non-null-assertion': 'off'
  }
}
```

## 6.sidebar 组件基本样式及配置

### 6.1 创建 Sidebar 组件

src/layout/components/Sidebar/index.vue

```vue
<template>sidebar</template>
```

在 layout/index.vue 中直接使用组件

```vue
<template>
  <div class="app-wrapper">
    <div class="sidebar-container">
      <sidebar></sidebar>
    </div>
    <div class="main-container">
      <div class="header">
        <div class="navbar">navbar</div>
        <div class="tags-view">tagsview</div>
      </div>
      <div class="app-main">
        <h2>app main</h2>
        <router-view></router-view>
      </div>
    </div>
  </div>
</template>
```

### 6.2 sidebar 中菜单组件属性配置

src/layout/components/Sidebar/index.vue

```vue
<template>
  <h4 @click="isCollapse = !isCollapse">展收测试</h4>
  <el-menu
    class="sidebar-container-menu"
    mode="vertical"
    :default-active="activeMenu"
    :background-color="scssVariables.menuBg"
    :text-color="scssVariables.menuText"
    :active-text-color="scssVariables.menuActiveText"
    :collapse="isCollapse"
    :collapse-transition="true"
  >
  </el-menu>
</template>
<script lang="ts" setup>
import scssVariables from "@/styles/variables.module.scss";
const route = useRoute();
// 根据路由路径 对应 当前激活的菜单 页面刷新后 激活当前路由匹配的菜单
const activeMenu = computed(() => {
  return route.path;
});
const isCollapse = ref(false);
</script>
```

使用 sass 时没有代码提示，我们来给 sass 增添类型声明文件
src/styles/variables.module.scss.d.ts

```ts
export interface ScssVariables {
  menuText: string;
  menuActiveText: string;
  subMenuActiveText: string;
  menuBg: string;
  menuHover: string;
  subMenuBg: string;
  subMenuHover: string;
  sideBarWidth: string;
}
export const variables: ScssVariables;
export default variables;
```

### 6.3 封装 SidebarItem 组件

src/layout/components/Sidebar/SidebarItem.vue

```vue
<template>
  <div class="sidebar-item-container">
    <el-menu-item index="1">
      <el-icon>
        <svg-icon class="menu-icon" icon-class="lock"></svg-icon>
      </el-icon>
      <template #title>
        <span>Dashoard</span>
      </template>
    </el-menu-item>
  </div>
</template>
```

### 6.4 sidebar 全局 css 样式改动

src/styles/sidebar.scss

```scss
#app {
  .sidebar-container {
    height: 100%;
    background-color: $menuBg;
    // menu未收起时样式
    &-menu:not(.el-menu--collapse) {
      width: $sideBarWidth;
    }
    .el-menu {
      border: none;
    }
  }
}
```

在 src/layout/components/Sidebar/index.vue 中引入 SidebarItem 组件

```vue
<template>
  <h4 @click="isCollapse = !isCollapse">展收测试</h4>
  <el-menu
    class="sidebar-container-menu"
    mode="vertical"
    :default-active="activeMenu"
    :background-color="scssVariables.menuBg"
    :text-color="scssVariables.menuText"
    :active-text-color="scssVariables.menuActiveText"
    :collapse="isCollapse"
    :collapse-transition="true"
  >
    <sidebar-item></sidebar-item>
  </el-menu>
</template>
```

### 6.5 创建路由页面

src/views/documentation/index.vue

```vue
<template>
  <div>
    <h1>Documentation page</h1>
  </div>
</template>
```

src/views/guide/index.vue

```vue
<template>
  <div>
    <h1>Guide page</h1>
  </div>
</template>
```

src/views/system/menu.vue

```vue
<template>
  <div>
    <h1>Menu page</h1>
  </div>
</template>
```

src/views/system/role.vue

```vue
<template>
  <div>
    <h1>Role page</h1>
  </div>
</template>
```

src/views/system/user.vue

```vue
<template>
  <div>
    <h1>User page</h1>
  </div>
</template>
```

### 6.5 路由注册

```ts
import { RouteRecordRaw, createRouter, createWebHistory } from "vue-router";
import Layout from "@/layout/index.vue";

// 看做是异步路由
export const asyncRoutes: Array<RouteRecordRaw> = [
  {
    path: "/documentation",
    component: Layout, // 布局组件作为一级路由
    redirect: "/documentation/index",
    children: [
      {
        path: "index",
        name: "Documentation",
        component: () =>
          import(
            /* webpackChunkName: "documentation" */
            "@/views/documentation/index.vue"
          ),
        meta: {
          title: "Documentation",
          icon: "documentation",
        },
      },
    ],
  },
  {
    path: "/guide",
    component: Layout,
    redirect: "/guide/index",
    children: [
      {
        path: "index",
        name: "Guide",
        component: () =>
          import(/* webpackChunkName: "guide" */ "@/views/guide/index.vue"),
        meta: {
          title: "Guide",
          icon: "guide",
        },
      },
    ],
  },
  {
    path: "/system",
    component: Layout,
    redirect: "/system/user",
    meta: {
      title: "System",
      icon: "lock",
    },
    children: [
      {
        path: "menu",
        component: () =>
          import(/* webpackChunkName: "menu" */ "@/views/system/menu.vue"),
        meta: {
          title: "Menu Management",
          icon: "list",
        },
      },
      {
        path: "role",
        component: () =>
          import(/* webpackChunkName: "role" */ "@/views/system/role.vue"),
        meta: {
          title: "Role Management",
          icon: "list",
        },
      },
      {
        path: "user",
        component: () =>
          import(/* webpackChunkName: "user" */ "@/views/system/user.vue"),
        meta: {
          title: "User Management",
          icon: "list",
        },
      },
    ],
  },
];
const constantRoutes: Array<RouteRecordRaw> = [
  {
    path: "/",
    component: Layout,
    redirect: "/dashboard",
    children: [
      {
        path: "dashboard",
        name: "Dashboard",
        component: () =>
          import(
            /* webpackChunkName: "dashboard" */
            "@/views/dashboard/index.vue"
          ),
        meta: {
          title: "Dashboard",
          icon: "dashboard",
        },
      },
    ],
  },
];
export const routes = [...constantRoutes, ...asyncRoutes];

export default createRouter({
  history: createWebHistory(),
  routes,
});
```

## 7. 路由菜单递归

### 7.1 导入路由表

> sidebar 组件导入路由表，根据 routes 循环 SidebarItem 组件

```vue
<template>
  <h4 @click="isCollapse = !isCollapse">展收测试</h4>
  <el-menu
    class="sidebar-container-menu"
    mode="vertical"
    :default-active="activeMenu"
    :background-color="scssVariables.menuBg"
    :text-color="scssVariables.menuText"
    :active-text-color="scssVariables.menuActiveText"
    :collapse="isCollapse"
    :collapse-transition="true"
  >
    <!-- 循环sidebar-item组件 -->
    <sidebar-item
      v-for="route in menuRoutes"
      :key="route.path"
      :item="route"
      :base-path="route.path"
    />
  </el-menu>
</template>
<script lang="ts" setup>
import scssVariables from "@/styles/variables.module.scss";
import SidebarItem from "./SidebarItem.vue";
// 导入路由表
import { routes } from "@/router";
// 渲染路由
const menuRoutes = computed(() => routes);
</script>
```

### 7.2 实现 SidebarItem 组件

```vue
<template>
  <div class="sidebar-item-container" v-if="!item.meta || !item.meta.hidden">
    <!-- 如果有一个孩子，或者没孩子，或者有一个孩子但是被hidden了 -->
    <template v-if="theOnlyOneChildRoute">
      <!-- 如果没有meta属性意味着不必渲染了 -->
      <el-menu-item
        :index="resolvePath(theOnlyOneChildRoute.path)"
        v-if="theOnlyOneChildRoute.meta"
      >
        <el-icon v-if="icon">
          <svg-icon class="menu-icon" :icon-class="icon"></svg-icon>
        </el-icon>
        <template #title>
          <span>{{ theOnlyOneChildRoute.meta?.title }}</span>
        </template>
      </el-menu-item>
    </template>
    <!-- 多个子路由时 -->
    <el-sub-menu v-else :index="resolvePath(item.path)" popper-appendto-body>
      <template #title>
        <el-icon v-if="item.meta?.icon">
          <svg-icon class="menu-icon" :icon-class="item.meta.icon"> </svg-icon>
        </el-icon>
        <span class="submenu-title">{{ item.meta?.title }}</span>
      </template>
      <sidebar-item
        v-for="child in item.children"
        :key="child.path"
        :is-nest="true"
        :item="child"
        :base-path="resolvePath(child.path)"
      >
      </sidebar-item>
    </el-sub-menu>
  </div>
</template>
<script setup lang="ts">
import type { PropType } from "vue";
import type { RouteRecordRaw } from "vue-router";
import path from "path-browserify";

const props = defineProps({
  item: {
    type: Object as PropType<RouteRecordRaw>,
    required: true,
  },
  basePath: {
    type: String,
    required: true,
  },
});
// 看看要渲染的儿子有多少
const showingChildNumber = computed(() => {
  const children = (props.item.children || []).filter((child) => {
    if (child.meta && child.meta.hidden) return false;
    return true;
  });
  return children.length;
});
const { item } = toRefs(props);
// 只处理一个儿子的情况
const theOnlyOneChildRoute = computed(() => {
  // 多个children时 直接return null 多children需要用el-submenu来渲染并递归
  if (showingChildNumber.value > 1) {
    return null;
  }
  // 只有一个子路由 还要筛选路由meta里有无hidden属性 hidden：true则过滤出去 不用管;
  // 路由meta里我们会配置hidden属性表示不渲染成菜单，比如login 401 404页面是不渲染成菜单的;
  if (item.value.children) {
    for (const child of item.value.children) {
      if (!child.meta || !child.meta.hidden) {
        return child;
      }
    }
  }
  // showingChildNumber === 0 无可渲染的子路由 （可能有子路由 hidden属性为true）
  // 无可渲染chiildren时 把当前路由item作为仅有的子路由渲染
  return {
    ...props.item,
    path: "",
  };
});

// menu icon
const icon = computed(() => {
  // 子路由 如果没有icon就用父路由的
  return (
    theOnlyOneChildRoute.value?.meta?.icon ||
    (props.item.meta && props.item.meta.icon)
  );
});

// 利用path.resolve 根据父路径+子路径 解析成正确路径 子路径可能是相对的
// resolvePath在模板中使用
const resolvePath = (childPath: string) => {
  return path.resolve(props.basePath, childPath);
};
</script>
```

> 安装 pnpm i path-browserify @types/path-browserify

### 7.3 sidebar css 样式调整

src/styles/sidebar.scss

```scss
#app {
  .sidebar-container {
    height: 100%;
    background-color: $menuBg;
    // menu未收起时样式
    &-menu:not(.el-menu--collapse) {
      width: $sideBarWidth;
    }
    .el-menu {
      border: none;
    }

    // 菜单收起时的样式调整
    .el-menu--collapse {
      // 隐藏submenu title
      .submenu-title {
        display: none;
      }
    }
    .el-submenu {
      .el-menu {
        .el-menu-item {
          background-color: $subMenuBg !important;
          &:hover {
            background-color: $subMenuHover !important;
          }
        }
      }
    }
  }
}
```

## 8. 菜单外链处理

### 8.1 创建 SidebarItemLink 组件

在这个组件里来判断 是否是带协议链接 如果是带协议链接 menu-item 里，就用 a 标签渲染
否则用 router-link 渲染 （注意 el-menu 路由模式不必开启 无需增添 router 属性）

> 用到了 component 动态组件 并以插槽形式包裹 SIdebarItem 组件

src/layout/components/Sidebar/SidebarItemLink.vue

```vue
<template>
  <component :is="type" v-bind="linkProps">
    <slot />
  </component>
</template>

<script lang="ts" setup>
import { isExternal } from "@/utils/validate";

// 针对路径是外链 就渲染成a标签 如果是正常路径 就渲染成router-link

const props = defineProps({
  to: {
    type: String,
    required: true,
  },
});

// 判断接受的路径 是不外链
const isExt = computed(() => isExternal(props.to));
const type = computed(() => {
  if (isExt.value) {
    return "a";
  }
  return "router-link";
});

const linkProps = computed(() => {
  if (isExt.value) {
    return {
      // a标签的原生属性
      href: props.to,
      target: "_blank",
      ref: "noopener",
    };
  }
  return {
    // router-link只需要一个to props
    to: props.to,
  };
});
</script>
```

### 8.2 SidebarItem 中使用 SidebarItemLink 组件

src/layout/components/Sidebar/SidebarItem.vue

```vue
<template>
  <div class="sidebar-item-container" v-if="!item.meta || !item.meta.hidden">
    <template v-if="theOnlyOneChildRoute">
      <sidebar-item-link
        :to="resolvePath(theOnlyOneChildRoute.path)"
        v-if="theOnlyOneChildRoute.meta"
      >
        <el-menu-item
          :index="resolvePath(theOnlyOneChildRoute.path)"
          v-if="theOnlyOneChildRoute.meta"
        >
          <el-icon>
            <svg-icon class="menu-icon" :icon-class="icon"></svg-icon>
          </el-icon>
          <template #title>
            <span>{{ theOnlyOneChildRoute.meta?.title }}</span>
          </template>
        </el-menu-item>
      </sidebar-item-link>
    </template>
    ...
  </div>
</template>
```

```ts
// 外链的话 直接返回
const resolvePath = (childPath: string) => {
  if (isExternal(childPath)) {
    return childPath;
  }
  return path.resolve(props.basePath, childPath);
};
```

### 8.3 添加外链路由

src/router.index.ts

```ts
export const asyncRoutes: Array<RouteRecordRaw> = [
  ...{
    // 外链路由
    path: "/external-link",
    component: Layout,
    children: [
      {
        path: "http://www.zhufengpeixun.com/",
        redirect: "/",
        meta: {
          title: "External Link",
          icon: "link",
        },
      },
    ],
  },
];
```

### 8.4 去掉 a 标签默认样式

src/styles/index.scss

```scss
// a标签默认样式调整
a:focus,
a:active {
  outline: none;
}
a,
a:focus,
a:hover {
  cursor: pointer;
  color: inherit;
  text-decoration: none;
}
```

## 9. 菜单支持路由 hidden 属性

> 主要是控制某些路由不用渲染成菜单，比如 login 404 401 等路由

默认 hidden 就是 false 显示在菜单

### 9.1 路由表里设置 hidden

```ts
{
    path: '/system',
    component: Layout,
    redirect: '/system/user',
    meta: {
      title: 'System',
      icon: 'lock'
    },
    children: [
      {
        path: 'menu',
        component: () =>
          import(/* webpackChunkName: "menu" */ '@/views/system/menu.vue'),
        meta: {
          title: 'Menu Management',
          icon: 'list',
          hidden: true
        }
      },
      {
        path: 'role',
        component: () =>
          import(/* webpackChunkName: "role" */ '@/views/system/role.vue'),
        meta: {
          title: 'Role Management',
          icon: 'list'
        }
      },
      {
        path: 'user',
        component: () =>
          import(/* webpackChunkName: "user" */ '@/views/system/user.vue'),
        meta: {
          title: 'User Management',
          icon: 'list'
        }
      }
    ]
  },
```

### 9.2 SidebarItem 组件修改

主要是在渲染菜单项前 根据 route.meta.hidden 属性进行筛选，将 hidden 为 true 的筛选出
去 不进行菜单渲染

```ts
const theOnlyOneChildRoute = computed(() => {
  ...
  return {
    ...props.item,
    path: '',
    noShowingChildren: true // 没有可渲染的children
  }
})
```

```vue
<template>
  <div class="sidebar-item-container" v-if="!item.meta || !item.meta.hidden">
    <!-- 就是这里添加了判断条件 -->
    <template
      v-if="
        theOnlyOneChildRoute &&
        (!theOnlyOneChildRoute.children ||
          theOnlyOneChildRoute.noShowingChildren)
      "
    >
      ...
    </template>
    <!-- 多个子路由 -->
    ...
  </div>
</template>
```

## 10. 添加路由缓存和转场动画

> 在 AppMain 中添加 keep-alive 组件（路由暂时先全部缓存）和 transition 组件 切换到其他路由页再回来内容还在

### 10.1 创建 AppMain 组件

src/layout/components/AppMain.vue

```vue
<template>
  <div class="app-main">
    <router-view v-slot="{ Component }">
      <transition name="fade-transform" mode="out-in">
        <keep-alive>
          <component :is="Component" :key="route.path" />
        </keep-alive>
      </transition>
    </router-view>
  </div>
</template>

<script lang="ts" setup>
import { useRoute } from "vue-router";
const route = useRoute();
</script>

<style lang="scss" scoped>
.app-main {
  /* navbar 50px */
  min-height: calc(100vh - 50px);
}

.fade-transform-enter-active,
.fade-transform-leave-active {
  transition: all 0.5s;
}

.fade-transform-enter-from {
  opacity: 0;
  transform: translateX(-30px);
}
.fade-transform-leave-to {
  opacity: 0;
  transform: translateX(30px);
}
</style>
```

### 10.2 layout 中导入 AppMain 组件

```vue
<template>
  <div class="app-wrapper">
    <div class="sidebar-container">
      <Sidebar></Sidebar>
    </div>
    <div class="main-container">
      <div class="header">
        <div class="navbar">navbar</div>
        <div class="tags-view">tagsview</div>
      </div>
      <!--
        <div class="app-main">
        <h2>app main</h2>
        <router-view></router-view>
        </div>
      -->
      <app-main></app-main>
    </div>
  </div>
</template>
```

### 10.3 缓存测试

src/views/dashboard/index.vue

```vue
<template>
  <div>
    <h1>Dashboard page</h1>
    <svg-icon icon-class="bug"></svg-icon>
    <!-- icon-class svg图标名称 class-name 额外的自定义类名 @click绑定事件 -->
    <svg-icon
      icon-class="404"
      class-name="custom-class"
      @click="sayHi"
    ></svg-icon>
    <br />
    <br />
    <br />
    <input type="text" />
    <el-button>按钮</el-button>
  </div>
</template>
</style>
```

::: tip
切换时在 .main-container 样式中增加 overflow:hidden 属性
:::

## 11. 菜单收缩按钮及介入 Pinia

### 11.1 创建菜单收缩按钮组件

src/components/Hambuger/index.vue

```vue
<template>
  <div class="hamburger-container" style="padding: 0 15px" @click="toggleClick">
    <svg-icon
      icon-class="list"
      class-name="hamburger"
      :class="{ 'is-active': props.isActive }"
    ></svg-icon>
  </div>
</template>

<script lang="ts" setup>
const props = defineProps({
  isActive: {
    type: Boolean,
    default: false,
  },
});
const emit = defineEmits(["toggleClick"]);
const toggleClick = () => {
  emit("toggleClick");
};
</script>

<style lang="scss" scoped>
.hamburger-container {
  line-height: 46px;
  height: 100%;
  float: left;
  cursor: pointer;
  transition: background 0.3s;
  -webkit-tap-highlight-color: transparent;
  &:hover {
    background: rgba(0, 0, 0, 0.025);
  }
}
:deep(.hamburger) {
  display: inline-block;
  vertical-align: middle;
  width: 20px;
  height: 20px;
  transition: all 0.2s;
}
:deep(.hamburger.is-active) {
  transform: rotate(180deg);
}
</style>
```

我们单独抽离一个 navbar 组件

src/layout/components/Navbar.vue

```vue
<template>
  <div class="navbar">
    <hambuger @toggleClick="toggleSidebar" :is-active="true" />
  </div>
</template>
<script lang="ts" setup>
const toggleSidebar = () => {
  console.log("click");
};
</script>
<style lang="scss" scoped>
.navbar {
  height: 50px;
}
</style>
```

src/layout/index.vue

```vue
<template>
  <div class="app-wrapper">
    <div class="sidebar-container">
      <sidebar></sidebar>
    </div>
    <div class="main-container">
      <div class="header">
        <!-- 换成navbar组件 -->
        <navbar></navbar>
        <div class="tags-view">tagsview</div>
      </div>
      <!-- <div class="app-main">
        <h2>app main</h2>
        <router-view></router-view>
      </div> -->
      <app-main></app-main>
    </div>
  </div>
</template>
```

### 11.2 接入 pinia

app store 针对一些后台设置状态存储 比如收缩状态 或配置状态

src/stores/app.ts

```ts
import { defineStore } from "pinia";
export const useAppStore = defineStore("app", () => {
  const state = reactive({
    sidebar: {
      opened: true,
    },
  });
  const sidebar = computed(() => state.sidebar);

  const toggleSidebar = () => {
    state.sidebar.opened = !state.sidebar.opened;
  };

  return {
    sidebar,
    toggleSidebar,
  };
});
```

### 11.3 使用 store 里 sidebar 状态

navbar 组件中接入 store.sidebar

```vue
<template>
  <div class="navbar">
    <hambuger
      @toggleClick="toggleSidebar"
      :is-active="sidebar.opened"
    ></hambuger>
  </div>
</template>

<script lang="ts" setup>
import { storeToRefs } from "pinia";
import { useAppStore } from "@/stores/app";

const store = useAppStore();
const { sidebar } = storeToRefs(store);

const toggleSidebar = () => {
  store.toggleSidebar();
};
</script>
```

src/layout/components/Sidebar/index.vue

改变了这个属性 **:collapse="sidebar.opened"**

```vue
<template>
  <el-menu
    class="sidebar-container-menu"
    mode="vertical"
    :default-active="activeMenu"
    :background-color="scssVariables.menuBg"
    :text-color="scssVariables.menuText"
    :active-text-color="scssVariables.menuActiveText"
    :collapse="sidebar.opened"
    :collapse-transition="true"
  >
    <sidebar-item
      v-for="route in menuRoutes"
      :key="route.path"
      :item="route"
      :base-path="route.path"
    ></sidebar-item>
  </el-menu>
</template>

<script lang="ts" setup>
import scssVariables from '@/styles/variables.module.scss'
import { useAppStore } from '@/stores/app'
import { storeToRefs } from 'pinia'

const store = useAppStore()
const { sidebar } = storeToRefs(store)
...
</script>
```

## 12. Pinia 持久化

### 12.1 菜单收缩状态进行 Pinia 状态持久化

> 主要依赖 pinia 插件 pinia-plugin-persistedstate 可以选择 storage 或自定义 可以部分
> 状态持久化

[pinia-plugin-persistedstate](https://github.com/prazdevs/pinia-plugin-persistedstate)

修改 src/main.ts

```ts
import { createPinia } from "pinia";
import piniaPluginPersistedstate from "pinia-plugin-persistedstate";
const pinia = createPinia();
pinia.use(piniaPluginPersistedstate);
app.use(pinia);
```

修改 src/stores/app.ts

```ts
import { defineStore } from "pinia";
export const useAppStore = defineStore(
  "app",
  () => {
    const state = reactive({
      sidebar: {
        opened: true,
      },
    });
    const sidebar = computed(() => state.sidebar);

    const toggleSidebar = () => {
      state.sidebar.opened = !state.sidebar.opened;
    };

    return {
      sidebar,
      toggleSidebar,
    };
  },
  {
    persist: {
      storage: window.sessionStorage,
      paths: ["state.sidebar.opened"],
    },
  }
);
```

## 13. 面包屑导航组件

:::tip
利用的是路由的 route.matched 属性
:::

### 13.1 route.matched

当路径是`/system/role`的时候会匹配到两条路径，`/system` 和 `/system/role` 就是会匹配父路径

### 13.2 安装 path-to-regexp

path-to-regexp 可以将动态路由路径/user/:id 转换成正则表达式。[Path-to-RegExp](https://github.com/pillarjs/path-to-regexp)

```bash
pnpm install path-to-regexp
```

这里我们要用它解决 面包屑导航是动态路由的情况下，点击面包屑导航 router.push 跳转时
怎么把动态参数填充进去 拼接成正常路由 `/user/:class/role/:id + {id: 2, class: 3} =>
/user/3/role/2` 然后正确跳转

### 13.3 创建 Breadcrumb 组件

src/components/Breadcrumb/index.vue

```vue
<template>
  <el-breadcrumb class="app-breadcrumb breadcrumb-container" separator="/">
    <el-breadcrumb-item v-for="(item, index) in levelList" :key="item.path">
      <!-- 面包屑导航最后一个是不可点击的 因为最后一个正是当前所显示的路由 -->
      <span v-if="index == levelList.length - 1" class="no-redirect">
        {{ item.meta?.title }}
      </span>
      <a v-else @click.prevent="handleLink(item)">{{ item.meta?.title }}</a>
    </el-breadcrumb-item>
  </el-breadcrumb>
</template>

<script lang="ts" setup>
import type { RouteLocationMatched, RouteLocationRaw } from "vue-router";
import { compile } from "path-to-regexp";
type PartialRouteLocationMatched = Partial<RouteLocationMatched>;

// 相当于this.$route对象
const route = useRoute();
// 相当于this.$router对象
const router = useRouter();
// 导航列表存放matched里筛选的路由记录
const levelList = ref<Array<PartialRouteLocationMatched>>([]);

const isDashboard = (route?: PartialRouteLocationMatched) => {
  const name = route && route.name;
  if (!name) {
    return false;
  }
  return (
    (name as string).trim().toLocaleLowerCase() ===
    "Dashboard".toLocaleLowerCase()
  );
};

//获取面包屑导航
const getBreadcrumb = () => {
  // 对匹配的路由进行过滤 过滤掉没有title属性的路由，没有title就无法作为面包屑导航
  let matched = route.matched.filter(
    (item) => item.meta && item.meta.title
  ) as PartialRouteLocationMatched[];

  console.log(matched, "matched");

  // 获取第一个匹配路由记录
  const first = matched[0];
  // 我们要把dashboard作为首页 始终固定在面包屑导航第一个 Dashboard/System/MenuManagement
  // 如果第一个匹配到的路由记录不是dashboard 我们自己就把它放在记录数组的第一项
  if (!isDashboard(first)) {
    matched = (
      [
        {
          path: "/dashboard",
          meta: {
            title: "Dashboard",
          },
        },
      ] as PartialRouteLocationMatched[]
    ).concat(matched);
  }

  levelList.value = matched.filter(
    (item) => item.meta && item.meta.title && item.meta.breadcrumb !== false
  );
};

watch(
  () => route.path,
  () => getBreadcrumb(),
  { immediate: true }
);

// 主要是针对 动态路由 /user/:id 进行动态参数填充
const pathCompile = (path: string) => {
  // 根据路径变编译成正则函数 并接收具体参数 比如根据正则/user/:id 帮你将:id替换成具体路径
  const toPath = compile(path); // 比如 path /user/:id
  const params = route.params; // {id: 10}
  return toPath(params); // toPath({ id: 10 }) => /user/10 返回填充后的路径
};

const handleLink = (route: PartialRouteLocationMatched[]) => {
  const { path, redirect } = route;
  if (redirect) {
    router.push(redirect as RouteLocationRaw);
    return;
  }
  router.push(pathCompile(path!));
};
</script>

<style lang="scss" scoped>
.app-breadcrumb.el-breadcrumb {
  display: inline-block;
  /* float: left; */
  line-height: 50px;
  font-size: 14px;
  margin-left: 8px;
}
.no-redirect {
  color: #97a8be;
  cursor: text;
}
</style>

<style lang="scss">
.breadcrumb-enter-active,
.breadcrumb-leave-active {
  transition: all 0.5s;
}
.breadcrumb-enter,
.breadcrumb-leave-active {
  opacity: 0;
  transform: translateX(20px);
}
.breadcrumb-leave-active {
  position: absolute;
}
.breadcrumb-move {
  transition: all 0.5s;
}
</style>
```

src/layout/components/Navbar.vue 引入 breadcrumb 组件

```vue
<template>
  <div class="navbar">
    <hambuger @toggleClick="toggleSidebar" :is-active="sidebar.opened" />
    <breadcrumb></breadcrumb>
  </div>
</template>
```

## 14.全屏组件切换按钮

> navbar 导航添加全屏切换按钮

### 14.1 实现 Screenfull 组件

**安装**

> pnpm install screenfull

src/components/Screenfull/index.vue

```vue
<template>
  <svg-icon
    :icon-class="isFullscreen ? 'exit-fullscreen' : 'fullscreen'"
    @click="handleClick"
  />
</template>

<script lang="ts" setup>
import screenfull from "screenfull";
import { onMounted } from "vue";

const { proxy } = getCurrentInstance()!;

const isFullscreen = ref(false);

const handleClick = () => {
  if (screenfull.isEnabled) {
    // 浏览器是否允许全屏
    screenfull.toggle();
    return;
  }
  return proxy?.$message({
    message: "you browser can not work",
    type: "warning",
  });
};

const change = () => {
  isFullscreen.value = screenfull.isFullscreen;
};

onMounted(() => {
  if (screenfull.isEnabled) {
    screenfull.on("change", change);
  }
});
</script>
```

**导入组件**
src/layout/components/Navbar.vue

```vue
<template>
  <div class="navbar">
    <hambuger
      @toggleClick="toggleSidebar"
      :is-active="sidebar.opened"
    ></hambuger>
    <breadcrumb></breadcrumb>
    <div class="right-menu">
      <screenfull class="right-menu-item hover-effect"></screenfull>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { storeToRefs } from "pinia";
import { useAppStore } from "@/stores/app";

const store = useAppStore();
const { sidebar } = storeToRefs(store);

const toggleSidebar = () => {
  store.toggleSidebar();
};
</script>

<style lang="scss" scoped>
.navbar {
  // height: 50px;
  display: flex;
  .right-menu {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 15px;
  }
}
</style>
```

## 15. element 组件 size 切换

### 15.1 定义类型

src/plugins/element.ts

```ts
export type Size = "default" | "large" | "small";
```

### 15.2 创建 sizeSelect 组件

```vue
<template>
  <el-dropdown trigger="click" @command="handleSize">
    <div>
      <svg-icon class-name="size-icon" icon-class="size"></svg-icon>
    </div>
    <template #dropdown>
      <el-dropdown-menu>
        <el-dropdown-item
          v-for="item in sizeOptions"
          :key="item.value"
          :command="item.value"
          :disabled="item.value === size"
        >
          {{ item.label }}
        </el-dropdown-item>
      </el-dropdown-menu>
    </template>
  </el-dropdown>
</template>

<script lang="ts" setup>
import { Size } from "@/plugins/element";
import { useAppStore } from "@/stores/app";
import { storeToRefs } from "pinia";

const store = useAppStore();
const { size } = storeToRefs(store);

const { proxy } = getCurrentInstance()!;
const sizeOptions = ref([
  { label: "Default", value: "default" },
  { label: "Large", value: "large" },
  { label: "Small", value: "small" },
]);

const handleSize = (command: Size) => {
  store.setSize(command);
  proxy?.$message.success({
    type: "success",
    message: "Switch Size Success",
  });
};
</script>
<style lang="scss">
.size-icon {
  font-size: 18px;
}
</style>
```

`navbar`中导入组件并调整样式

src/layout/components/Navbar.vue

```vue
<template>
  <div class="navbar">
    <hambuger
      @toggleClick="toggleSidebar"
      :is-active="sidebar.opened"
    ></hambuger>
    <breadcrumb></breadcrumb>
    <div class="right-menu">
      <screenfull class="right-menu-item hover-effect"></screenfull>

      <el-tooltip content="Global Size" effect="dark">
        <size-select class="right-menu-item hover-effect" />
      </el-tooltip>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { storeToRefs } from "pinia";
import { useAppStore } from "@/stores/app";

const store = useAppStore();
const { sidebar } = storeToRefs(store);

const toggleSidebar = () => {
  store.toggleSidebar();
};
</script>

<style lang="scss" scoped>
.navbar {
  // height: 50px;
  display: flex;
  .right-menu {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 15px;
    &-item {
      padding: 0 8px;
      font-size: 18px;
      color: #5a5e66;
      vertical-align: text-bottom;
      &.hover-effect {
        cursor: pointer;
        transition: background 0.3s;
        &:hover {
          background: rgba(0, 0, 0, 0.025);
        }
      }
    }
  }
}
</style>
```

### 15.3 size 属性添加到 store

修改 src/stores/app.ts

```ts
import { defineStore } from "pinia";
import { Size } from "@/plugins/element";

interface stateType {
  sidebar: sidebarType;
  size: Size;
}

interface sidebarType {
  opened: boolean;
}

export const useAppStore = defineStore(
  "app",
  () => {
    const state = reactive<stateType>({
      sidebar: {
        opened: true,
      },
      size: "default",
    });
    const sidebar = computed(() => state.sidebar);
    const size = computed(() => state.size);

    const toggleSidebar = () => {
      state.sidebar.opened = !state.sidebar.opened;
    };
    const setSize = (size: Size) => {
      state.size = size;
    };

    return {
      state,
      sidebar,
      size,
      setSize,
      toggleSidebar,
    };
  },
  {
    persist: {
      storage: window.sessionStorage,
      paths: ["state.sidebar.opened", "state.size"],
    },
  }
);
```

:::tip
注意这里的 `stateType`、`sidebarType` 这两个类型，如果不定义的话，在 App.vue 中 `el-config-provider` 的 `size` 属性会提示错误，解决的方法有两种：

1. size as any
2. 在定义 size 的时候就给上类型即可
   :::

### 15.4 设置组件 siz

src/components/SizeSelect/index.vue

```ts
import { useAppStore } from "@/stores/app";
import { storeToRefs } from "pinia";

const store = useAppStore();
const { size } = storeToRefs(store);
```

将 `size` 应用在 `App.vue` 中

```vue
<template>
  <el-config-provider :size="size">
    <router-view></router-view>
  </el-config-provider>
</template>

<script setup lang="ts">
import { useAppStore } from "@/stores/app";
import { storeToRefs } from "pinia";
const store = useAppStore();
const { size } = storeToRefs(store);
</script>
```

### 15.5 组件国际化

```vue
<template>
  <el-config-provider :size="size" :locale="zhCn">
    <router-view></router-view>
  </el-config-provider>
</template>
<script setup lang="ts">
import zhCn from "element-plus/dist/locale/zh-cn.mjs";
</script>
```

这里还需要在 `src/vite-env.d.ts` 中添加类型声明

```ts
declare module "element-plus/dist/locale/zh-cn.mjs";
```

## 16. 添加用户头像 avatar 组件

### 16.1 创建 avatar 组件

src/components/Avatar/index.vue

```vue
<template>
  <el-dropdown class="avatar-container">
    <div class="avatar-wrapper">
      <img :src="avatar" class="user-avatar" />
      <i class="el-icon-caret-bottom" />
    </div>
    <template #dropdown>
      <el-dropdown-menu>
        <router-link to="/">
          <el-dropdown-item>首页</el-dropdown-item>
        </router-link>
        <router-link to="/profile/index">
          <el-dropdown-item>个人设置</el-dropdown-item>
        </router-link>
        <el-dropdown-item divided @click="logout">
          <span style="display: block">退出登录</span>
        </el-dropdown-item>
      </el-dropdown-menu>
    </template>
  </el-dropdown>
</template>

<script lang="ts" setup>
import avatar from "@/assets/vue.svg";
const logout = () => {
  console.log("退出登录");
};
</script>

<style lang="scss" scoped>
.avatar-container {
  margin-right: 30px;
  .avatar-wrapper {
    margin-top: 5px;
    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      cursor: pointer;
    }
    .el-icon-caret-bottom {
      cursor: pointer;
      font-size: 12px;
    }
  }
}
</style>
```

### 16.2 navbar 中导入组件

src/layout/components/Navbar.vue

```vue
<template>
  <div class="navbar">
    <hambuger @toggleClick="toggleSidebar" :is-active="sidebar.opened" />
    <breadcrumb></breadcrumb>
    <div class="right-menu">
      <screenfull class="right-menu-item hover-effect"></screenfull>
      <!-- element组件size切换 -->
      <el-tooltip content="Global Size" effect="dark" placement="bottom">
        <size-select class="right-menu-item hover-effect" />
      </el-tooltip>
      <avatar />
    </div>
  </div>
</template>
```

## 17. 标签导航基本功能

### 17.1 定义 store

src/stores/tagsView.ts

```ts
import { defineStore } from "pinia";
import { RouteLocationNormalizedLoaded } from "vue-router";
export const useTagsView = defineStore("tag", () => {
  const visitedViews = ref<RouteLocationNormalizedLoaded[]>([]);
  // 添加视图
  const addView = (view: RouteLocationNormalizedLoaded) => {
    // 去重
    if (visitedViews.value.some((v) => v.path === view.path)) return;
    // 没有title的处理
    visitedViews.value.push(
      Object.assign({}, view, {
        title: view.meta?.title || "tag-name",
      })
    );
  };
  // 删除视图
  const delView = (view: RouteLocationNormalizedLoaded) => {
    const i = visitedViews.value.indexOf(view);
    if (i > -1) {
      visitedViews.value.splice(i, 1);
    }
  };
  return { visitedViews, addView, delView };
});
```

### 17.2 创建 TagsView 组件

src/layout/components/TagsView/index.vue

```vue
<template>
  <div class="tags-view-container">
    <div class="tags-view-wrapper">
      <!-- 一个个tag view就是router-link -->
      <router-link
        class="tags-view-item"
        :class="{
          active: isActive(tag),
        }"
        v-for="(tag, index) in visitedViews"
        :key="index"
        :to="{ path: tag.path, query: tag.query }"
      >
        <span>{{ tag.meta.title }}</span>
        <el-icon class="icon-close">
          <CloseBold @click.prevent.stop="closeSelectedTag(tag)" />
        </el-icon>
      </router-link>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { useTagsView } from "@/stores/tagsView";
import { storeToRefs } from "pinia";
import { RouteLocationNormalized } from "vue-router";
import { CloseBold } from "@element-plus/icons-vue";
const store = useTagsView();
const { visitedViews } = storeToRefs(store);
const route = useRoute();
// 从store里获取 可显示的tags view
// 添加tag
const addTags = () => {
  const { name } = route;
  if (name) {
    store.addView(route);
  }
};
watch(
  () => route.path,
  () => {
    addTags();
  },
  { immediate: true }
);
// 是否是当前应该激活的tag
const isActive = (tag: RouteLocationNormalized) => {
  return tag.path === route.path;
};

// 关闭当前右键的tag路由
const closeSelectedTag = (view: RouteLocationNormalized) => {
  store.delView(view);
};
</script>
<style lang="scss" scoped>
.tags-view-container {
  width: 100%;
  height: 34px;
  background: #fff;
  border-bottom: 1px solid #d8dce5;
  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.12), 0 0 3px 0 rgba(0, 0, 0, 0.04);
  .tags-view-wrapper {
    .tags-view-item {
      display: inline-block;
      height: 26px;
      line-height: 26px;
      border: 1px solid #d8dce5;
      background: #fff;
      color: #495060;
      padding: 0 8px;
      box-sizing: border-box;
      font-size: 12px;
      margin-left: 5px;
      margin-top: 4px;
      &:first-of-type {
        margin-left: 15px;
      }
      &:last-of-type {
        margin-right: 15px;
      }
      &.active {
        background-color: #42b983;
        color: #fff;
        border-color: #42b983;
        &::before {
          position: relative;
          display: inline-block;
          content: "";
          width: 8px;
          height: 8px;
          border-radius: 50%;
          margin-right: 5px;
          background: #fff;
        }
      }
    }
    span {
      vertical-align: middle;
    }
  }
  .icon-close {
    width: 16px;
    height: 16px;
    vertical-align: middle;
    position: relative;
    left: 2px;
    border-radius: 50%;
    text-align: center;
    transition: all 0.3s cubic-bezier(0.645, 0.045, 0.355, 1);
    transform-origin: 100% 50%;
    &:before {
      transform: scale(0.6);
      display: inline-block;
      vertical-align: -1px;
    }
    &:hover {
      background-color: #b4bccc;
      color: #fff;
    }
  }
}
</style>
```

> 这里需要安装 pnpm i @element-plus/icons-vue 图标库

src/layout/index.vue 中引入 tagsView 组件

```vue
<template>
  <div class="app-wrapper">
    <div class="sidebar-container">
      <Sidebar></Sidebar>
    </div>
    <div class="main-container">
      <div class="header">
        <navbar></navbar>
        <!-- 加了这里 -->
        <tags-view></tags-view>
      </div>
      <app-main></app-main>
    </div>
  </div>
</template>
```

修改 navbar 样式

src/layout/components/Navbar.vue

```scss
.navbar {
  display: flex;
  background: #fff;
  border-bottom: 1px solid rgba(0, 21, 41, 0.08);
  box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);
}
```

## 18. 标签导航删除选中处理

> 当删除的是激活状态 tag 时，我就让剩下集合中最后一个为激活态并跳转到对应路由

### 18.1 修改 tagviews 组件

> 删除后 调用 toLastView 方法，从剩下集合中得到最后一个路由 tag 触发路由跳转 即可

```ts
// 关闭当前右键的tag路由
const closeSelectedTag = (view: RouteLocationNormalized) => {
  store.delView(view);
  if (isActive(view)) {
    toLastView(visitedViews.value, view);
  }
};

const router = useRouter();
const toLastView = (
  visitedViews: RouteLocationNormalized[],
  view: RouteLocationNormalized
) => {
  // 得到集合中最后一项的tag view 可能没有
  const lastView = visitedViews[visitedViews.length - 1];
  if (lastView) {
    router.push(lastView.path);
  } else {
    // 集合中都没有tag view时
    // 如果刚刚删除的正是Dashboard 就重定向回Dashboard（首页）
    if (view.name === "Dashboard") {
      router.push({ path: view.path });
    } else {
      // tag都没有了 删除的也不是Dashboard 只能跳转首页
      router.push("/");
    }
  }
};
```

## 19. 标签导航支持固定 tag

> 通过路由 meta 里添加 affix 属性为 true，就让当前路由 tag 始终固定在标签导航

### 19.1 Dashboard 路由 meta 中添加 affix: true

### 19.2 修改 tagsView 组件

在页面最开始加载的时候就要筛选出有 affix 的路由，渲染到页面上，并且不显示关闭的 icon

src/layout/components/TagsView/index.vue

```vue
<template>
  <el-icon class="icon-close" v-if="!isAffix(tag)">
    <CloseBold @click.prevent.stop="closeSelectedTag(tag)" />
  </el-icon>
</template>
<script lang="ts" setup>
import { RouteLocationNormalized, RouteRecordRaw } from "vue-router";
import path from "path-browserify";
import { routes } from "@/router";
const filterAffixTags = (routes: RouteRecordRaw[], basePath = "/") => {
  let tags: RouteLocationNormalized[] = [];
  routes.forEach((route) => {
    if (route.meta && route.meta.affix) {
      // 把路由路径解析成完整路径，路由可能是相对路径
      const tagPath = path.resolve(basePath, route.path);
      tags.push({
        name: route.name,
        path: tagPath,
        meta: { ...route.meta },
      } as RouteLocationNormalized);
    }
    // 深度优先遍历 子路由（子路由路径可能相对于route.path父路由路径）
    if (route.children) {
      const childTags = filterAffixTags(route.children, route.path);
      if (childTags.length) {
        tags = [...tags, ...childTags];
      }
    }
  });
  return tags;
};
const initTags = () => {
  const affixTags = filterAffixTags(routes);
  for (const tag of affixTags) {
    if (tag.name) {
      store.addView(tag);
    }
  }
};
const isAffix = (tag: RouteLocationNormalized) => {
  return tag.meta && tag.meta.affix;
};
onMounted(() => {
  initTags();
});
</script>
```

## 20. 标签导航支持横向滑动

> 当标签导航太多时，超出页面宽度时，可以左右横向滑动

### 20.1 添加 scrollbar 组件

创建 ScrollPanel 组件

src/layout/components/TagsView/ScrollPanel.vue

```vue
<template>
  <el-scrollbar wrap-class="scroll-wrapper">
    <slot />
  </el-scrollbar>
</template>
<style lang="scss">
.scroll-wrapper {
  position: relative;
  width: 100%;
  white-space: nowrap;
}
</style>
```

### 20.2 修改 tagsview

用 scrollpanel 组件包裹 tagsview 组件

```vue
<template>
  <div class="tags-view-container">
    +
    <scroll-panel>
      <div class="tags-view-wrapper">
        <!-- 一个个tag view就是router-link -->
        <router-link
          class="tags-view-item"
          :class="{
            active: isActive(tag),
          }"
          v-for="(tag, index) in visitedViews"
          :key="index"
          :to="{ path: tag.path, query: tag.query }"
        >
          <span>{{ tag.meta.title }}</span>
          <el-icon class="icon-close" v-if="!isAffix(tag)">
            <CloseBold @click.prevent.stop="closeSelectedTag(tag)" />
          </el-icon>
        </router-link>
      </div>
      +
    </scroll-panel>
  </div>
</template>
<style lang="scss" scoped>
.tags-view-container {
 width: 100%;
 height: 34px;
 background: #fff;
 border-bottom: 1px solid #d8dce5;
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.12), 0 0 3px 0 rgba(0, 0, 0,
0.04);
+ overflow: hidden;
}
</style>
```

### 20.3 注意使用标签导航

> 使用标签导航的路由 必须要 name 属性 因为方便我们根据 name 进行路由筛选和缓存 keep-alive

给 `menu` `role` `user` 添加 name 属性，因为 tagView 里面是根据 name 筛选的

```ts
children: [
  {
    path: "menu",
    name: "Menu Management",
    component: () =>
      import(/* webpackChunkName: "menu" */ "@/views/system/menu.vue"),
    meta: {
      title: "Menu Management",
      icon: "list",
      hidden: true,
    },
  },
  {
    path: "role",
    name: "Role Management",
    component: () =>
      import(/* webpackChunkName: "role" */ "@/views/system/role.vue"),
    meta: {
      title: "Role Management",
      icon: "list",
    },
  },
  {
    path: "user",
    name: "User Management",
    component: () =>
      import(/* webpackChunkName: "user" */ "@/views/system/user.vue"),
    meta: {
      title: "User Management",
      icon: "list",
    },
  },
];
```

## 21. 标签导航支持对应路由缓存

### 21.1 标签导航支持对应路由缓存

:::tip
再添加标签导航时，同时也判断该路由要不要缓存，要缓存就根据路由配置的 name 属
性进行缓存（路由组件的 name 要与路由配置的 name 一致）再添加到 keep-alive
inludes 的缓存列表中。
（keep-alive 内部是根据组件的 name 进行缓存，我们添加到 cachedViews 缓存列表的
name 是从每条路由配置的 name 取得值，所以路由组件和路由配置中必须要有一致的
name 属性。）
:::

src/stores/tagsView.ts

```ts
import { defineStore } from "pinia";
import { RouteLocationNormalizedLoaded, RouteRecordName } from "vue-router";
export const useTagsView = defineStore("tag", () => {
  const visitedViews = ref<RouteLocationNormalizedLoaded[]>([]);
  // 添加视图
  const addView = (view: RouteLocationNormalizedLoaded) => {
    // 去重
    if (visitedViews.value.some((v) => v.path === view.path)) return;
    // 没有title的处理
    visitedViews.value.push(
      Object.assign({}, view, {
        title: view.meta?.title || "tag-name",
      })
    );
    addCachedView(view);
  };
  // 删除视图
  const delView = (view: RouteLocationNormalizedLoaded) => {
    const i = visitedViews.value.indexOf(view);
    if (i > -1) {
      visitedViews.value.splice(i, 1);
    }
    delCachedView(view);
  };

  const cachedViews = ref<RouteRecordName[]>([]);

  const addCachedView = (view: RouteLocationNormalizedLoaded) => {
    if (cachedViews.value.includes(view.name!)) return;
    if (!view.meta.noCache) {
      cachedViews.value.push(view.name!);
    }
  };

  const delCachedView = (view: RouteLocationNormalizedLoaded) => {
    // 删除缓存
    const index = cachedViews.value.indexOf(view.name!);
    index > -1 && cachedViews.value.splice(index, 1);
  };

  return { visitedViews, addView, delView, cachedViews };
});
```

### 21.2 AppMain 中根据 store 中 cachedViews 列表进行缓存

> 给 keep-alive 添加 includes 列表，从 store 中获取 cachedViews 缓存列表作为 includes 列表

src/layout/components/AppMain.vue

```vue
<template>
  <div class="app-main">
    <router-view v-slot="{ Component }">
      <transition name="fade-transform" mode="out-in">
        <keep-alive :include="includes">
          <component :is="Component" :key="route.path" />
        </keep-alive>
      </transition>
    </router-view>
  </div>
</template>

<script lang="ts" setup>
import { useRoute } from "vue-router";
import { useTagsView } from "@/stores/tagsView";
import { storeToRefs } from "pinia";
const route = useRoute();
const store = useTagsView();

const { cachedViews } = storeToRefs(store);
const includes = computed(() => cachedViews.value as string[]);
</script>
```

### 21.3 给组件添加 name 属性

vite.config.ts

> 安装插件 unplugin-vue-define-options/vite 定义 name 属性

```bash
pnpm install unplugin-vue-define-options -D
```

```ts
import DefineOptions from "unplugin-vue-define-options/vite";
export default defineConfig({
  plugins: [vue(), DefineOptions()],
});
```

```vue
<template>
  <div>
    <el-button>按钮</el-button>
    <input type="text" />
  </div>
</template>
<script setup lang="ts">
defineOptions({ name: "Dashboard" });
</script>
```

解决 ts 报错问题 tsconfig.json

```json
{
  "compilerOptions": {
    // ...
    "types": [
      "element-plus/global",
      "unplugin-vue-define-options/macros-global"
    ]
  }
}
```

解决 eslint 报错问题 .eslintrc.cjs

```js
module.exports = {
  // ...
  globals: {
    defineOptions: "readonly",
  },
};
```

## 22. 右键菜单

> 通过右键选择 关闭所有、 关闭其他、 关闭当前、刷新 对于 tag affix 为 true 的固定 tag 是不允许关闭删除的

### 22.1 修改 tagsView 组件

添加下拉菜单

> 需要使用 element dropdown 组件，给每一个 tag 添加。

src/layout/components/TagsView/index.vue

```vue
<template>
  <div class="tags-view-container">
    <scroll-panel>
      <div class="tags-view-wrapper">
        <!-- 一个个tag view就是router-link -->
        <router-link
          class="tags-view-item"
          :class="{
            active: isActive(tag),
          }"
          v-for="(tag, index) in visitedViews"
          :key="index"
          :to="{ path: tag.path, query: tag.query }"
        >
          <el-dropdown
            trigger="contextmenu"
            @command="(command: any) => handleTagCommand(command, tag)"
          >
            <span style="line-height: 26px">{{ tag.meta.title }}</span>
            <span
              v-if="!isAffix(tag)"
              class="el-icon-close"
              @click.prevent.stop="closeSelectedTag(tag)"
            ></span>
            <template #dropdown>
              <el-dropdown-item command="all">关闭所有</el-dropdown-item>
              <el-dropdown-item command="other">关闭其他</el-dropdown-item>
              <el-dropdown-item command="self">关闭</el-dropdown-item>
              <el-dropdown-item command="refresh">刷新</el-dropdown-item>
            </template>
          </el-dropdown>
          <el-icon class="icon-close" v-if="!isAffix(tag)">
            <CloseBold @click.prevent.stop="closeSelectedTag(tag)" />
          </el-icon>
        </router-link>
      </div>
    </scroll-panel>
  </div>
</template>
```

### 22.2 添加右键事件

```ts
const enum TagCommandType {
  All = "all",
  Other = "other",
  Self = "self",
  Refresh = "refresh",
}
const handleTagCommand = (
  command: TagCommandType,
  view: RouteLocationNormalized
) => {
  switch (command) {
    case TagCommandType.All: // 右键删除标签导航所有tag 除了affix为true的
      // handleCloseAllTag(view)
      break;
    case TagCommandType.Other: // 关闭其他tag 除了affix为true的和当前右键的
      tag;
      // handleCloseOtherTag(view)
      break;
    case TagCommandType.Self: // 关闭当前右键的tag affix为true的tag下拉菜单中
      无此项;
      // closeSelectedTag(view)
      break;
    case TagCommandType.Refresh: // 刷新当前右键选中tag对应的路由
      // refreshSelectedTag(view)
      break;
  }
};
```

### 22.3 修改 store

> 我们的 tag 列表和缓存列表都在 store 所有对于它们的增删改查需要 调用 action 来删除

src/stores/tagsView.ts

```ts
const delAllView = () => {
  visitedViews.value = visitedViews.value.filter((tag) => tag.meta.affix);
  cachedViews.value = [];
};

const delOthersViews = (view: RouteLocationNormalized) => {
  visitedViews.value = visitedViews.value.filter(
    (tag) => tag.meta.affix || tag.path === view.path
  );
  cachedViews.value = cachedViews.value.filter((name) => name !== view.name);
};

/* 记得return */
```

### 22.4 右键关闭其他和关闭和右键刷新

src/layout/components/TagsView/index.vue

```vue
<template>
  ...
  <el-dropdown-menu>
    <el-dropdown-item command="all">关闭所有</el-dropdown-item>
    <el-dropdown-item command="other">关闭其他</el-dropdown-item>
    +
    <el-dropdown-item command="self" v-if="!tag.meta || !tag.meta.affix"
      >关闭</el-dropdown-item
    >
    <el-dropdown-item command="refresh">刷新</el-dropdown-item>
  </el-dropdown-menu>
  ...
</template>

<script lang="ts" setup>
const handleTagCommand = (
  command: TagCommandType,
  view: RouteLocationNormalized
) => {
  switch (command) {
    case TagCommandType.All: // 右键删除标签导航所有tag 除了affix为true的
      handleCloseAllTag(view);
      break;
    case TagCommandType.Other: // 关闭其他tag 除了affix为true的和当前右键的
      tag;
      handleCloseOtherTag(view);
      break;
    case TagCommandType.Self: // 关闭当前右键的tag affix为true的tag下拉菜单中
      无此项;
      closeSelectedTag(view);
      break;
    case TagCommandType.Refresh: // 刷新当前右键选中tag对应的路由
      refreshSelectedTag(view);
      break;
  }
};

const handleCloseAllTag = (view: RouteLocationNormalized) => {
  // 对于是affix的tag是不会被删除的
  store.delAllView();
  // 关闭所有后 就让切换到剩下affix中最后一个tag
  toLastView(visitedViews.value, view);
};
const handleCloseOtherTag = (view: RouteLocationNormalized) => {
  store.delOthersViews(view);
  if (!isActive(view)) {
    // 删除其他tag后 让该view路由激活
    router.push(view.path);
  }
};

const refreshSelectedTag = async (view: RouteLocationNormalized) => {
  // 刷新前 将该路由名称从缓存列表中移除
  store.delCachedView(view);
  // router.push(view.path) // 无法刷新页面，因为页面没有任何变化
  router.push("/redirect" + view.path); // 跳转重定向路由
};
</script>
```

### 22.5 重定向路由

src/router/index.ts

```ts
const constantRoutes: Array<RouteRecordRaw> = [
  ...,
  {
    path: "/redirect",
    component: Layout,
    meta: {
      hidden: true,
    },
    children: [
      {
        // 带参数的动态路由正则匹配 文档说明
        // https://next.router.vuejs.org/zh/guide/essentials/routematchingsyntax.html#%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E5%8F%82%E6%95%B0
        path: "/redirect/:path(.*)", // 要匹配多级路由 应该加*号
        component: () => import("@/views/redirect/index.vue"),
      },
    ],
  },
];
```

增添 src/views/redirect/index.vue 页面

```vue
<script lang="ts">
export default {
  name: "Redirect",
  setup() {
    const route = useRoute();
    const router = useRouter();
    const { query, params } = route;
    router.replace({
      path: "/" + params.path,
      query,
    });
    return () => {
      return h("template");
    };
  },
};
</script>
```

### 22.6 404 路由添加

```ts
const constantRoutes: Array<RouteRecordRaw> = [
  ...,
  {
    path: "/:pathMatch(.*)*",
    redirect: "/404",
    meta: {
      hidden: true,
    },
  },
  {
    path: "/404",
    component: () => import("@/views/error-page/404.vue"),
    meta: {
      hidden: true, // 404 hidden掉
    },
  },
];
```

src/views/error-page/404.vue

```vue
<template>404</template>
```

## 23.动态修改主题

### 23.1 Navbar 添加设置图标

src/layout/components/Navbar.vue

```vue
<template>
  <div class="navbar">
    <hambuger @toggleClick="toggleSidebar" :is-active="sidebar.opened" />
    <breadcrumb></breadcrumb>
    <div class="right-menu">
      <!-- 设置 -->
      <div
        @click="openShowSetting"
        class="setting right-menu-item hover-effect"
      >
        <el-icon><Setting /></el-icon>
      </div>
      <!-- ... -->
    </div>
  </div>
</template>
<script lang="ts" setup>
// ...
import { Setting } from "@element-plus/icons-vue";
const emit = defineEmits<{
  (event: "showSetting", isShow: boolean): void;
}>();
// 打开设置面板,触发对应的事件
const openShowSetting = () => {
  emit("showSetting", true);
};
</script>
<style lang="scss" scoped>
.navbar {
  display: flex;
  background: #fff;
  border-bottom: 1px solid rgba(0, 21, 41, 0.08);
  box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);
  .right-menu {
    // ...
    .setting {
      font-size: 26px;
      display: flex;
      align-items: center;
    }
  }
}
</style>
```

### 23.2 封装 RightPanel 组件

点击设置右边出来设置面板

src/components/RightPanel/index.vue

```vue
import { emit } from 'process';
<template>
  <div class="right-panel">
    <el-drawer
      :model-value="modelValue"
      :direction="direction"
      :show-close="showClose"
      :custom-class="customClass"
      :with-header="withHeader"
      :title="title"
      :size="size"
      @close="handleClose"
    >
      <slot />
    </el-drawer>
  </div>
</template>

<script lang="ts" setup>
defineProps({
  modelValue: {
    type: Boolean,
    default: true,
  },
  direction: {
    type: String,
    validator(val: string) {
      return ["rtl", "ltr", "ttb", "btt"].includes(val);
    },
    default: "rtl",
  },
  title: {
    type: String,
    default: "自定义title",
  },
  size: {
    type: [String, Number],
  },
  customClass: {
    type: String,
    default: "setting-panel",
  },
  showClose: {
    type: Boolean,
    default: true,
  },
  withHeader: {
    type: Boolean,
    default: true,
  },
});

const emit = defineEmits(["update:modelValue", "close"]);
const handleClose = () => {
  emit("update:modelValue", false);
  emit("close");
};
</script>
```

src/layout/index.vue

```vue
<template>
  <div class="app-wrapper">
    <div class="sidebar-container">
      <Sidebar></Sidebar>
    </div>
    <div class="main-container">
      <div class="header">
        <navbar @showSetting="openSetting"></navbar>
        <tags-view></tags-view>
      </div>
      <app-main></app-main>
    </div>
    <!-- 增添right-panel -->
    <right-panel
      v-model="showSetting"
      title="样式风格设置"
      :size="settingsPanelWidth"
    >
      <!-- settings 面板设置组件,稍后实现 -->
      <settings />
    </right-panel>
  </div>
</template>
<script lang="ts" setup>
import variables from "@/styles/variables.module.scss";

const showSetting = ref(false);

const openSetting = () => {
  // 控制right-panel弹出
  showSetting.value = true;
};
const settingsPanelWidth = computed(() => variables.settingPanelWidth);
</script>
```

**调整样式修改 scss 变量**

src/styles/variables.module.scss

```scss
$settingPanelWidth: 260px;
$theme: #409eff;
:export {
  ....
  theme: $theme;
  settingPanelWidth: $settingPanelWidth;
}
```

variables.module.scss.d

```ts
export interface ScssVariables {
  ...
  theme: string
  settingPanelWidth: string
}

```

### 23.3 store 中存储 theme

src/stores/settings.ts

```ts
import variables from "@/styles/variables.module.scss";
import { defineStore } from "pinia";

export const useSettingsStore = defineStore(
  "settings",
  () => {
    // theme是用户选择的主题
    // originalTheme是现在生效的主题, 刷新需要重新生成无需存放到sessionStorage中
    const settings = reactive({ theme: variables.theme, originalTheme: "" });
    type ISettings = typeof settings;
    type ValueOf<T> = T[keyof T];

    // 修改设置
    const changeSetting = ({
      key,
      value,
    }: {
      key: keyof ISettings;
      value: ValueOf<ISettings>;
    }) => {
      settings[key] = value;
    };

    return { settings, changeSetting };
  },
  {
    persist: {
      storage: window.sessionStorage,
      paths: ["settings.theme"],
    },
  }
);
```

### 23.4 创建 ThemePicker 组件

src/components/ThemePicker/index.vue

```vue
<template>
  <el-color-picker
    v-model="theme"
    class="theme-picker"
    :predefine="themeColor"
    popper-class="theme-picker-dropdown"
  />
</template>
<script lang="ts" setup>
// 预设可选颜色
import { useSettingsStore } from "@/stores/settings";
const store = useSettingsStore();
const themeColor = [
  "#409EFF",
  "#1890ff",
  "#304156",
  "#212121",
  "#11a983",
  "#13c2c2",
  "#6959CD",
  "#f5222d",
];
// store中获取默认主题色
const defaultTheme = computed(() => store.settings.theme);
const theme = ref("");

// 监听默认样式
watch(
  defaultTheme,
  (value) => {
    theme.value = value;
  },
  {
    immediate: true,
  }
);
// 根据theme选择变化 重新生成主题
watch(theme, (value) => {
  // 同步store
  store.changeSetting({ key: "theme", value });
  // 稍后这里生成主题
  // 同步store
  // generateTheme(value)
});
</script>
<style lang="scss">
.theme-picker {
  height: 26px !important;
  margin-right: 8px;
  .el-color-picker__trigger {
    height: 26px !important;
    width: 26px !important;
    padding: 2px;
  }
}
.theme-message,
.theme-picker-dropdown {
  z-index: 99999 !important;
}
.theme-picker-dropdown .el-color-dropdown__link-btn {
  display: none;
}
</style>
```

### 23.5 创建 Settings 组件

src/layout/components/Settings/index.vue

```vue
<template>
  <div class="drawer-container">
    <div class="drawer-item">
      <span>主题色</span>
      <theme-picker />
    </div>
  </div>
</template>
<style lang="scss" scoped>
.drawer-container {
  padding: 24px;
  font-size: 14px;
  line-height: 1.5;
  word-wrap: break-word;
  .drawer-item {
    display: flex;
    justify-content: space-between;
    padding: 12px 0;
    font-size: 16px;
    color: rgba(0, 0, 0, 0.65);
  }
}
</style>
```

### 23.6 安装 css-color-function

> 将通过该包提供的 convert 函数生成将 css color-mod 函数生成的渐变色 转换成 rgb

```
// 下面color函数以及 shade tin是css的color-mod函数
// 了解文档 http://cdn1.w3cplus.com/css4/color-mod.html
'color(#11A983 shade(10%))' => 'rgb(15, 152, 118)'
'color(#11A983 tint(10%))' => 'rgb(41, 178, 143)'
'color(#11A983 tint(20%))' => 'rgb(65, 186, 156)'
'color(#11A983 tint(30%))' => 'rgb(88, 195, 168)'
'color(#11A983 tint(40%))' => 'rgb(112, 203, 181)'
'color(#11A983 tint(50%))' => 'rgb(136, 212, 193)'
'color(#11A983 tint(60%))' => 'rgb(160, 221, 205)'
'color(#11A983 tint(70%))' => 'rgb(184, 229, 218)'
'color(#11A983 tint(80%))' => 'rgb(207, 238, 230)'
'color(#11A983 tint(90%))' => 'rgb(231, 246, 243)'
// 利用css-color-function转换为rgb
import color from 'css-color-function'
color.convert('color(#11A983 shade(10%))') // 'rgb(15, 152, 118)'
```

> pnpm i css-color-function

需要注意该包没有声明文件 需要自己定义下

/src/vite-env.d.ts

```ts
declare module "css-color-function" {
  export function convert(color: string): string;
}
```

编写生成样式方法

src/utils/color.ts

```ts
import color from "css-color-function";
const formula: { [prop: string]: string } = {
  "primary-light-1": "color(primary tint(10%))",
  "primary-light-2": "color(primary tint(20%))",
  "primary-light-3": "color(primary tint(30%))",
  "primary-light-4": "color(primary tint(40%))",
  "primary-light-5": "color(primary tint(50%))",
  "primary-light-6": "color(primary tint(60%))",
  "primary-light-7": "color(primary tint(70%))",
  "primary-light-8": "color(primary tint(80%))",
  "primary-light-9": "color(primary tint(90%))",
};
const generateColors = (primary: string) => {
  const colors: Record<string, string> = {};
  Object.keys(formula).forEach((key) => {
    const value = formula[key].replace(/primary/g, primary);
    colors[key] = color.convert(value); // 转换成rgba颜色值
  });
  return colors;
};
const setColors = (colors: Record<string, string>) => {
  const el = document.documentElement;
  Object.entries(colors).map(([key, value]) => {
    el.style.setProperty(`--el-color-${key}`, value);
  });
};
export { generateColors, setColors };
```

### 23.7 主题生成逻辑

> 最开始需要在 App.vue 中调用生成主题 hooks useGenerateTheme
> ThemePicker 组件里也要调用 useGenerateTheme 更好选择的主题颜色 生成主题

src/App.vue

```vue
<template>
  <el-config-provider :size="size" :locale="zhCn">
    <router-view></router-view>
  </el-config-provider>
</template>
<script setup lang="ts">
import zhCn from "element-plus/dist/locale/zh-cn.mjs";
import { storeToRefs } from "pinia";
+import { useGenerateTheme } from "@/hook/useGenerateTheme";
import { useAppStore } from "./stores/app";
const store = useAppStore();
const { size } = storeToRefs(store);
+ useGenerateTheme();
</script>
```

创建 useGenerateTheme Hook 函数

src/hooks/useGenerateTheme.ts

```ts
import { useSettingsStore } from "@/stores/settings";
import { generateColors, setColors } from "@/utils/color";
export const useGenerateTheme = () => {
  // 获得settingsStore
  const store = useSettingsStore();
  const theme = computed(() => store.settings.theme); // 默认主题
  const originalTheme = computed(() => store.settings.originalTheme);
  const generateTheme = (primary: string) => {
    const colors = Object.assign(
      // 根据当前主题生成
      {
        primary: theme.value,
      },
      generateColors(primary)
    );
    setColors(colors);
  };
  // 用户选择的主题和当前主题不一致，则生成主题
  if (theme.value !== originalTheme.value) {
    generateTheme(theme.value);
    // 同步最新主题
    store.changeSetting({ key: "originalTheme", value: theme.value });
  }
  return {
    generateTheme,
  };
};
```

### 23.8 修改 tagviews 组件使用主题色

src/layout/components/TagsView/index.vue

```vue
<template>
  <router-link
    ...
    :style="{
      backgroundColor: isActive(tag) ? themeColor : '',
      borderColor: isActive(tag) ? themeColor : '',
    }"
  >
    ...
  </router-link>
</template>

<script lang="ts" setup>
// 主题色
import { useSettingsStore } from "@/stores/settings";
const settingStore = useSettingsStore();
const themeColor = computed(() => settingStore.settings.theme);
</script>
```

### 23.9 修改 sidebar 使用主题色

```vue
<template>
  <el-menu ... :active-text-color="themeColor" ...>
    <!-- 循环sidebar-item组件 -->
    ...
  </el-menu>
</template>

<script lang="ts" setup>
// 主题色
import { useSettingsStore } from "@/stores/settings";
const settingStore = useSettingsStore();
const themeColor = computed(() => settingStore.settings.theme);
</script>
```

## 24. 标签导航显示切换

### 24.1 store 中定义导航显示状态

添加 tagsView 字段

```ts
import variables from "@/styles/variables.module.scss";
import { defineStore } from "pinia";

export const useSettingsStore = defineStore(
  "settings",
  () => {
    // theme是用户选择的主题
    // originalTheme是现在生效的主题, 刷新需要重新生成无需存放到sessionStorage中
    const settings = reactive({
      theme: variables.theme,
      originalTheme: "",
      tagsView: true,
    });
    type ISettings = typeof settings;
    type ValueOf<T> = T[keyof T];

    // 修改设置
    const changeSetting = ({
      key,
      value,
    }: {
      key: keyof ISettings;
      value: ValueOf<ISettings>;
    }) => {
      if (key in settings) {
        (settings[key] as ValueOf<ISettings>) = value;
      }
    };

    return { settings, changeSetting };
  },
  {
    persist: {
      storage: window.sessionStorage,
      paths: ["settings.theme", "settings.tagsView"],
    },
  }
);
```

### 24.2 修改 Settings 组件添加切换按钮

src/layout/components/Settings/index.vue

```vue
<template>
  <div class="drawer-container">
    <div class="drawer-item">
      <span>主题色</span>
      <theme-picker />
    </div>
    <div class="drawer-item">
      <span>Open Tags-View</span>
      <el-switch v-model="tagsView" class="drawer-switch"></el-switch>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { useSettingsStore } from "@/stores/settings";

const settingStore = useSettingsStore();

const tagsView = computed({
  get() {
    return settingStore.settings.tagsView;
  },
  set(val) {
    settingStore.changeSetting({
      key: "tagsView",
      value: val,
    });
  },
});
</script>

<style lang="scss" scoped>
.drawer-container {
  padding: 24px;
  font-size: 14px;
  line-height: 1.5;
  word-wrap: break-word;
  .drawer-item {
    display: flex;
    justify-content: space-between;
    padding: 12px 0;
    font-size: 16px;
    color: rgba(0, 0, 0, 0.65);
  }
}
</style>
```

### 24.3 Layout 中添加条件控制

src/layout/index.vue

```vue
<template>
  <div class="app-wrapper">
    <div class="sidebar-container">
      <sidebar></sidebar>
    </div>
    <div class="main-container">
      <div class="header">
        <navbar @showSetting="openSetting"></navbar>
        <tags-view v-if="showTagsView"></tags-view>
      </div>
      <!-- <div class="app-main">
        <h2>app main</h2>
        <router-view></router-view>
      </div> -->
      <app-main></app-main>
    </div>
    <right-panel
      v-model="showSetting"
      title="样式风格设置"
      :size="settingsPanelWidth"
    >
      <settings />
    </right-panel>
  </div>
</template>

<script lang="ts" setup>
import { useSettingsStore } from "@/stores/settings";
import variables from "@/styles/variables.module.scss";

const settingsStore = useSettingsStore();
const showTagsView = computed(() => settingsStore.settings.tagsView);
const otherHeight = computed(() => (showSetting.value ? 84 : 50) + "px");
const showSetting = ref(false);

const openSetting = () => {
  showSetting.value = true;
};

const settingsPanelWidth = computed(() => variables.settingPanelWidth);
</script>

<style lang="scss" scoped>
.app-wrapper {
  display: flex;
  width: 100%;
  height: 100%;
  .main-container {
    flex: 1;
    display: flex;
    overflow: hidden;

    flex-direction: column;
    .header {
      .navbar {
        height: 50px;
      }
      .tags-view {
        height: 34px;
      }
    }
    // 新增
    .app-main {
      min-height: calc(100vh - v-bind(otherHeight));
    }
  }
}
</style>
```

## 25. 侧边栏 logo 显示控制

### 25.1 store 中添加状态

src/stores/settings.ts

```ts
import variables from "@/styles/variables.module.scss";
import { defineStore } from "pinia";

export const useSettingsStore = defineStore(
  "settings",
  () => {
    // theme是用户选择的主题
    // originalTheme是现在生效的主题, 刷新需要重新生成无需存放到sessionStorage中
    const settings = reactive({
      theme: variables.theme,
      originalTheme: "",
      tagsView: true,
      sidebarLogo: true,
    });
    type ISettings = typeof settings;
    type ValueOf<T> = T[keyof T];

    // 修改设置
    const changeSetting = ({
      key,
      value,
    }: {
      key: keyof ISettings;
      value: ValueOf<ISettings>;
    }) => {
      if (key in settings) {
        (settings[key] as ValueOf<ISettings>) = value;
      }
    };

    return { settings, changeSetting };
  },
  {
    persist: {
      storage: window.sessionStorage,
      paths: ["settings.theme", "settings.tagsView", "settings.sidebarLogo"],
    },
  }
);
```

### 25.2 修改 Settings

src/layout/components/Settings/index.vue

```vue
<template>
  <div class="drawer-container">
    ...
    <div class="drawer-item">
      <span>Sidebar Logo</span>
      <el-switch v-model="showSidebarLogo" class="drawer-switch"></el-switch>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { useSettingsStore } from "@/stores/settings";

const settingStore = useSettingsStore();

const showSidebarLogo = computed({
  get() {
    return settingStore.settings.sidebarLogo;
  },
  set(val) {
    settingStore.changeSetting({
      key: "sidebarLogo",
      value: val,
    });
  },
});
</script>
```

### 25.3 创建 logo 组件

```vue
<template>
  <div class="sidebar-logo-container" :class="{ collapse: collapse }">
    <transition name="sidebarLogoFade">
      <!-- sidebar收起状态下 -->
      <router-link
        v-if="collapse"
        key="collapse"
        to="/"
        class="sidebar-logo-link"
      >
        <img
          v-if="logo"
          :src="logo"
          class="sidebar-logo"
          alt="VueElementAdmin"
        />
        <h1 v-else class="sidebar-title">{{ title }}</h1>
      </router-link>
      <router-link v-else key="expand" to="/" class="sidebar-logo-link">
        <img
          v-if="logo"
          :src="logo"
          class="sidebar-logo"
          alt="VueElementAdmin"
        />
        <h1 class="sidebar-title">{{ title }}</h1>
      </router-link>
    </transition>
  </div>
</template>

<script lang="ts" setup>
import logo from "@/assets/vue.svg";
defineProps({
  collapse: {
    type: Boolean,
    required: true,
  },
});
const title = "Vue Element Admin";
</script>

<style lang="scss" scoped>
.sidebar-logo-container {
  width: 100%;
  height: 50px;
  line-height: 50px;
  text-align: center;
  background: #2b2f3a;
  overflow: hidden;
  .sidebar-logo-link {
    display: block;
    width: 100%;
    height: 100%;
    .sidebar-logo {
      width: 32px;
      height: 32px;
      vertical-align: middle;
      margin-right: 12px;
    }
    .sidebar-title {
      display: inline-block;
      color: #fff;
      margin: 0;
      font-weight: 600;
      line-height: 50px;
      font-size: 14px;
      font-family: Avenir, Helvetica Neue, Arial, Helvetica, sans-serif;
      vertical-align: middle;
    }
  }
  &.collapse {
    .sidebar-logo {
      margin-right: 0;
    }
  }
}
.sidebarLogoFade-enter-active {
  transition: opacity 1.5s;
}
.sidebarLogoFade-enter-from,
.sidebarLogoFade-leave-to {
  opacity: 0;
}
</style>
```

### 25.4 sidebar 里添加 logo

```vue
<template>
  <logo v-if="showLogo" :collapse="isCollapse" />
  <el-menu
    class="sidebar-container-menu"
    mode="vertical"
    :default-active="activeMenu"
    :background-color="scssVariables.menuBg"
    :text-color="scssVariables.menuText"
    :active-text-color="themeColor"
    :collapse="sidebar.opened"
    :collapse-transition="true"
  >
    <!-- 循环sidebar-item组件 -->
    <sidebar-item
      v-for="route in menuRoutes"
      :key="route.path"
      :item="route"
      :base-path="route.path"
    />
  </el-menu>
</template>
<script lang="ts" setup>
// ...
// 是否显示logo
const showLogo = computed(() => settingStore.settings.sidebarLogo);
// 展开收起状态 稍后放store 当前是展开就让它收起
const isCollapse = computed(() => store.sidebar.opened);
</script>
```

## 26. 侧边栏支持滚动

### 26.1 修改 sidebar

> sidebar 组件中添加 scrollPanel 组件

src/layout/components/Sidebar/index.vue

```vue
<template>
  <div class="sidebar-wrapper">
    <logo v-if="showLogo" :collapse="isCollapse" />
    <scroll-panel>
      <el-menu
        class="sidebar-container-menu"
        mode="vertical"
        :default-active="activeMenu"
        :background-color="scssVariables.menuBg"
        :text-color="scssVariables.menuText"
        :active-text-color="themeColor"
        :collapse="sidebar.opened"
        :collapse-transition="true"
      >
        <!-- 循环sidebar-item组件 -->
        <sidebar-item
          v-for="route in menuRoutes"
          :key="route.path"
          :item="route"
          :base-path="route.path"
        />
      </el-menu>
    </scroll-panel>
  </div>
</template>
<script lang="ts" setup>
const logoHeight = computed(() => (showLogo.value ? 50 : 0) + "px");
</script>
<style lang="scss" scoped>
.sidebar-wrapper {
  .sidebar-container-menu {
    height: calc(100vh - v-bind(logoHeight));
  }
}
</style>
```

### 26.2 scrollPanel 组件

> 之前在 tagsview 文件夹里就有 scrollPanel 组件， 可以共用一个， 从
> layout/components/TagsView 里 把 ScrollPanel.vue 移动到 src/components 里

## 27. 登录页基本布局

### 27.1 注册登录路由

src/router/index.ts

> 注册 login 路由 放到 constantRoutes 集合里

```ts
const constantRoutes: Array<RouteRecordRaw> = [
  //....
  {
    path: "/login",
    name: "Login",
    component: () => import("@/views/login/index.vue"),
  },
];
```

### 27.2 创建 login 路由页面

src/views/login/index.vue

```vue
<template>
  <div class="login-container">
    <el-form class="login-form">
      <div class="admin-logo">
        <img class="logo" src="../../assets/vue.svg" alt="logo" />
        <h1 class="name">Vue3 Admin</h1>
      </div>
      <el-form-item prop="username">
        <el-input placeholder="请输入用户名">
          <template #prepend>
            <span class="svg-container">
              <svg-icon icon-class="user"></svg-icon>
            </span>
          </template>
        </el-input>
      </el-form-item>
      <el-form-item>
        <el-input
          type="password"
          placeholder="请输入密码"
          autocomplete="on"
          show-password
        >
          <template #prepend>
            <span class="svg-container">
              <svg-icon icon-class="password"></svg-icon>
            </span>
          </template>
        </el-input>
      </el-form-item>
      <!-- 登录按钮 -->
      <el-button
        type="primary"
        style="width: 100%; margin-bottom: 30px"
        :loading="loading"
        @click="handleLogin"
        >Login</el-button
      >
    </el-form>
  </div>
</template>
<script lang="ts" setup>
const loading = ref(false);
const handleLogin = () => {
  console.log("login");
};
</script>
<style lang="scss">
$bg: #283443;
$light_gray: #fff;
$cursor: #fff;
.login-container {
  .el-form-item {
    .el-input {
      height: 40px;
    }
  }
}
</style>
<style lang="scss" scoped>
$bg: #2d3a4b;
$dark_gray: #889aa4;
$light_gray: #eee;
.login-container {
  min-height: 100%;
  width: 100%;
  overflow: hidden;
  background-repeat: no-repeat;
  background-position: 50%;
  background-size: 100%;
  .login-form {
    position: relative;
    width: 500px;
    max-width: 100%;
    margin: 0 auto;
    padding: 140px 35px 0;
    overflow: hidden;
    box-sizing: border-box;
    .admin-logo {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
      .logo {
        width: 60px;
        height: 60px;
      }
      .name {
        font-weight: normal;
        margin-left: 10px;
      }
    }
  }
}
</style>
```

## 28.登录效验和数据绑定

### 28.1 修改登录页

> 添加数据效验和绑定

src/views/login/index.vue

```vue
<template>
  <div class="login-container">
    <el-form
      class="login-form"
      :model="loginForm"
      :rules="loginRules"
      ref="loginFormRef"
    >
      <div class="admin-logo">
        <img class="logo" src="../../assets/vue.svg" alt="logo" />
        <h1 class="name">Vue3 Admin</h1>
      </div>
      <el-form-item prop="username">
        <el-input
          placeholder="请输入用户名"
          v-model="loginForm.username"
          ref="usernameRef"
          autocomplete="off"
          tabindex="1"
        >
          <template #prepend>
            <span class="svg-container">
              <svg-icon icon-class="user"></svg-icon>
            </span>
          </template>
        </el-input>
      </el-form-item>
      <el-form-item prop="password">
        <el-input
          type="password"
          v-model="loginForm.password"
          placeholder="请输入密码"
          autocomplete="off"
          show-password
          tabindex="2"
        >
          <template #prepend>
            <span class="svg-container">
              <svg-icon icon-class="password"></svg-icon>
            </span>
          </template>
        </el-input>
      </el-form-item>
      <!-- 登录按钮 -->
      <el-button
        type="primary"
        style="width: 100%; margin-bottom: 30px"
        :loading="loading"
        @click="handleLogin"
        >Login</el-button
      >
    </el-form>
  </div>
</template>
<script lang="ts" setup>
import { FormInstance } from "element-plus";

const loading = ref(false);
// ref
const loginFormRef = ref<FormInstance | null>(null);
// username
const usernameRef = ref<HTMLInputElement | null>(null);
// password
const passwordRef = ref<HTMLInputElement | null>(null);

const loginState = reactive({
  loginForm: {
    username: "",
    password: "",
  },
  loginRules: {
    username: [
      {
        required: true,
        trigger: "blur",
        message: "请输入用户名！",
      },
    ],
    password: [
      {
        required: true,
        trigger: "blur",
        message: "请输入密码",
      },
    ],
  },
});

const handleLogin = () => {
  loginFormRef.value?.validate((valid) => {
    if (valid) {
      console.log(loginState.loginForm);
    }
  });
};
// 解构
const { loginForm, loginRules } = toRefs(loginState);
// 自动获取焦点
onMounted(() => {
  if (loginState.loginForm.username === "") {
    usernameRef.value?.focus();
  } else if (loginState.loginForm.password === "") {
    passwordRef.value?.focus();
  }
});
</script>
<style lang="scss">
$bg: #283443;
$light_gray: #fff;
$cursor: #fff;
.login-container {
  .el-form-item {
    .el-input {
      height: 40px;
    }
  }
}
</style>
<style lang="scss" scoped>
$bg: #2d3a4b;
$dark_gray: #889aa4;
$light_gray: #eee;
.login-container {
  min-height: 100%;
  width: 100%;
  overflow: hidden;
  background-repeat: no-repeat;
  background-position: 50%;
  background-size: 100%;
  .login-form {
    position: relative;
    width: 500px;
    max-width: 100%;
    margin: 0 auto;
    padding: 140px 35px 0;
    overflow: hidden;
    box-sizing: border-box;
    .admin-logo {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
      .logo {
        width: 60px;
        height: 60px;
      }
      .name {
        font-weight: normal;
        margin-left: 10px;
      }
    }
  }
}
</style>
```

## 29. 接入登录接口

### 29.1 环境变量配置

vue3-element-admin 根目录下创建环境变量文件，生产环境这里只是写个假的

.env.development

> VITE_BASE_API = /dev-api

.env.production

> VITE_BASE_API = /prod-api

**utils 里封装 token 存储操作方法**

src/utils/auth.ts

```ts
const tokenKey = "V3-Admin-Token";
export const getToken = (): string | null => {
  return localStorage.getItem(tokenKey);
};
export const setToken = (token: string): void => {
  return localStorage.setItem(tokenKey, token);
};
export const removeToken = (): void => {
  return localStorage.removeItem(tokenKey);
};
```

### 29.2 创建 api

**封装 request.ts**

```bash
pnpm install axios
```

src/api/config/request.ts

```ts
import axios from "axios";
import { getToken } from "../../utils/auth";
import { ElMessage } from "element-plus";
const service = axios.create({
  baseURL: import.meta.env.VITE_BASE_API,
  timeout: 100000,
});
service.interceptors.request.use(
  (config) => {
    const token = getToken();
    if (token) {
      // 携带token
      config.headers!.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    console.log(error);
    return Promise.reject(error);
  }
);
service.interceptors.response.use(
  (response) => {
    const { code, message } = response.data;
    if (code !== 0) {
      // 错误提示
      ElMessage.error(message);
      return Promise.reject(message);
    }
    return response.data;
  },
  (error) => {
    console.log("err" + error); // for debug
    return Promise.reject(error);
  }
);
export default service;
```

**封装响应类型**

src/api/type.ts

```ts
export interface ApiResponse<T = any> {
  code: number;
  data: T;
  message?: string;
}
```

**创建 user api**

src/api/user.ts

```ts
import request from "@/api/config/request";
import { ApiResponse } from "./type";
interface UserLoginData {
  username: string;
  password: string;
}
interface LoginResponseData {
  token: string;
}
export const login = (
  data: UserLoginData
): Promise<ApiResponse<LoginResponseData>> => {
  return request.post("/auth/login", data);
};
```

### 29.3 创建 userStore

src/stores/user.ts

```ts
import { defineStore } from "pinia";
import { login as loginApi } from "@/api/config/user";
import { setToken } from "@/utils/auth";
// login params
export interface IUserInfo {
  username: string;
  password: string;
}
export const useUserStore = defineStore("user", () => {
  // 状态
  const state = reactive({
    token: "",
  });
  const login = async (userInfo: IUserInfo) => {
    try {
      const { username, password } = userInfo;
      const response = await loginApi({ username: username.trim(), password });
      const { data } = response;
      state.token = data.token;
      setToken(data.token);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  return { state, login };
});
```

### 29.4 接入登录逻辑

src/views/login/index.vue

```vue
<script lang="ts" setup>
const userStore = useUserStore();
const router = useRouter();
const handleLogin = () => {
  loginFormRef.value?.validate(async (valid) => {
    if (valid) {
      loading.value = true;
      try {
        await userStore.login(loginState.loginForm);
        router.push({ path: "/" });
      } finally {
        loading.value = false;
      }
    } else {
      console.log("error submit");
    }
  });
};
</script>
```

### 29.5 设置代理

vite.config.ts

```ts

export default defineConfig({
  ...
  server: {
    proxy: {
      '/dev-api': {
        target: 'http://localhost:3000',
        ws: true,
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/dev-api/, '/api')
      }
    }
  }
})
```

## 30.完成登录验证

### 30.1 安装 nProgress 进度条

```bash
pnpm install --save nprogress
# ts
pnpm install -D @types/nprogress
```

### 30.2 添加路由验证

**创建 permission.ts**

> 添加路由导航钩子，进行登录验证

src/permission.ts

```ts
import router from "@/router";
import nProgress from "nprogress";
import "nprogress/nprogress.css"; // progress bar style
import { getToken } from "./utils/auth";
nProgress.configure({ showSpinner: false });
const whiteList = ["/login"]; // 白名单
router.beforeEach((to) => {
  nProgress.start();
  const hasToken = getToken();
  if (hasToken) {
    // 有token代表已登录
    if (to.path === "/login") {
      nProgress.done();
      return {
        path: "/",
        replace: true,
      };
    }
    nProgress.done();
    return true;
  } else {
    if (whiteList.includes(to.path)) {
      nProgress.done();
      return true;
    }
    nProgress.done();
    return {
      path: "/login",
      query: {
        redirect: to.path,
        ...to.query,
      },
    };
  }
});
router.afterEach(() => {
  nProgress.done();
});
```

> 在 main.ts 中引入 permission.ts

### 30.3 登录后跳转逻辑修改

src/hook/useRouteQuery.ts

**创建 useRouteQuery hook**

获取 url query 并得到 redirect 参数 redirect 参数或作为登录成功后跳转路径

```ts
import { Ref } from "vue";
import { useRoute, LocationQueryRaw } from "vue-router";
interface RouteQuery {
  redirect: Ref<string>;
  otherQuery: Ref<LocationQueryRaw | undefined>;
}
const useRouteQuery = (): RouteQuery => {
  const route = useRoute();
  const query = route.query;
  const redirect = ref("");
  const otherQuery = ref<LocationQueryRaw | undefined>(undefined);
  const getOtherQuery = (query: LocationQueryRaw) => {
    return Object.keys(query || {})
      .filter((q) => q !== "redirect")
      .reduce((obj, key) => {
        obj[key] = query[key];
        return obj;
      }, {} as LocationQueryRaw);
  };
  otherQuery.value = getOtherQuery(query);
  watchEffect(() => {
    const query = route.query;
    if (query) {
      redirect.value = query.redirect as string;
      otherQuery.value = getOtherQuery(query as LocationQueryRaw);
    }
  });
  return {
    redirect,
    otherQuery,
  };
};
export default useRouteQuery;
```

src/views/login/index.vue

```vue
<script lang="ts" setup>
import useRouteQuery from "@/hook/useRouteQuery";
const { redirect, otherQuery } = useRouteQuery();
const handleLogin = () => {
  loginFormRef.value?.validate(async (valid) => {
    if (valid) {
      loading.value = true;
      try {
        await userStore.login(loginState.loginForm);
        router.push({ path: redirect.value || "/", query: otherQuery.value });
      } finally {
        loading.value = false;
      }
    } else {
      console.log("error submit");
    }
  });
};
</script>
```

## 31. 实现退出登录

### 31.1 store 里添加 logout

退出登录时 调用 logout 清空 store token tags view 刷新跳转到登录页

src/stores/user.ts

```ts

export interface IUserInfo {
  username: string
  password: string
}

export const useUserStore = defineStore('user', () => {
  ....
  const { delAllView } = useTagsView()
  const logout = () => {
    state.token = ''
    removeToken()
    delAllView()
  }

  return {
    state,
    login,
    logout
  }
})

```

### 31.2 退出登录

src/components/Avatar/index.vue

```vue
<template>
  <el-dropdown class="avatar-container">
    <div class="avatar-wrapper">
      <img :src="avatar" class="user-avatar" />
      <i class="el-icon-caret-bottom" />
    </div>
    <template #dropdown>
      <el-dropdown-menu>
        <router-link to="/">
          <el-dropdown-item>首页</el-dropdown-item>
        </router-link>
        <router-link to="/profile/index">
          <el-dropdown-item>个人设置</el-dropdown-item>
        </router-link>
        <el-dropdown-item divided @click="logout">
          <span style="display: block">退出登录</span>
        </el-dropdown-item>
      </el-dropdown-menu>
    </template>
  </el-dropdown>
</template>
<script lang="ts" setup>
import avatar from "@/assets/vue.svg";
import { useUserStore } from "@/stores/user";
const store = useUserStore();
const { proxy } = getCurrentInstance()!;
const logout = () => {
  store.logout();
  proxy?.$message.success("退出登录");
  window.location.reload();
};
</script>
```

登录成功加了个提示

src/views/login/index.vue

```vue
<script lang="ts" setup>
const { proxy } = getCurrentInstance()!;

const handleLogin = () => {
  loginFormRef.value?.validate(async (valid) => {
    if (valid) {
      loading.value = true;
      try {
        await userStore.login(loginState.loginForm);
        // 登录成功提示
        proxy?.$message.success("登录成功");
        router.push({ path: redirect.value || "/", query: otherQuery.value });
      } finally {
        loading.value = false;
      }
    } else {
      console.log("error submit");
    }
  });
};
</script>
```

## 32. 错误码 401 token 失效处理

### 32.1 添加 resetToken

> 清空 token

src/stores/user.ts

```ts
const resetToken = () => {
  // 清空store里token
  state.token = "";
  // 清空localStorage里的token
  removeToken();
};
return { state, login, logout, resetToken };
```

### 32.2 修改 request.js 拦截 401 错误

src/api/config/request.ts

```ts

import axios, { AxiosError } from 'axios'
import { useUserStore } from '@/stores/user'

....

service.interceptors.response.use(
  (response) => {
    const { code, message } = response.data
    if (code !== 0) {
      // 错误提示
      ElMessage.error(message)
      return Promise.reject(message)
    }
    return response.data
  },
  (error: AxiosError) => {
    const res = error?.response
    if (res && res.status === 401) {
      // 401 未登录 token失效
      const store = useUserStore()
      store.resetToken()
      window.location.reload()
    }
    ElMessage.error(error.message)
    return Promise.reject(error)
  }
)
```

## 33.用户管理

### 33.1 用户相关 api

src/api/config/user.ts

```ts
// -------------用户接口------------
// 获取用户信息
interface UserBody {
  token: string;
}
export interface Role {
  id: number;
  name: string;
  description: string;
}
export interface Profile {
  avatar: string;
  email: string;
  id: number;
  isSuper: boolean;
  mobile: string;
  status: boolean;
  username: string;
  description: string;
  roles: Role[];
  roleIds?: number[];
}
export const getUserInfo = (data?: UserBody): Promise<ApiResponse<Profile>> => {
  return request.post("/auth/info", data);
};
// 获取用户列表
export interface IUsers {
  users: Profile[];
  count: number;
}
export interface IUserQuery {
  pageNum?: number;
  pageSize?: number;
  mobile?: string;
  status?: boolean;
  username?: string;
}
export const getUsers = (params: IUserQuery): Promise<ApiResponse<IUsers>> => {
  const {
    pageNum = 0,
    pageSize = 10,
    username = "",
    status,
    mobile = "",
  } = params;
  return request.get("/user", {
    params: {
      pageNum,
      pageSize,
      username,
      status,
      mobile,
    },
  });
};
// 添加用户
export const removeUser = (id: number): Promise<ApiResponse> => {
  return request.delete(`/user/${id}`);
};
// 添加用户
export const addUser = (data: Profile): Promise<ApiResponse> => {
  return request.post("/auth/register", data);
};
// 编辑用户
export const updateUser = (id: number, data: Profile): Promise<ApiResponse> => {
  return request.put(`/user/${id}`, data);
};
```

### 33.2 用户 store

src/stores/user.ts

```ts
import { defineStore } from "pinia";
import {
  getUsers as getUsersApi,
  addUser as addUserApi,
  removeUser as removeUserApi,
  getUserInfo as getUserInfoApi,
  updateUser as updateUserApi,
  login as loginApi,
} from "@/api/config/user";
import type { IUserQuery, IUsers, Profile, Role } from "@/api/config/user";
import { removeToken, setToken } from "@/utils/auth";
import { useTagsView } from "./tagsView";
// login params
export interface IUserInfo {
  username: string;
  password: string;
}
export type IProfileQuery = Profile & {
  pageNum?: number;
  pageSize?: number;
};
export const useUserStore = defineStore("user", () => {
  // 状态
  const state = reactive({
    token: "",
    userInfo: null as Profile | null,
    users: [] as IUsers["users"],
    count: 0,
    roles: null as Role[] | null,
  });
  const login = async (userInfo: IUserInfo) => {
    try {
      const { username, password } = userInfo;
      const response = await loginApi({ username: username.trim(), password });
      const { data } = response;
      state.token = data.token;
      setToken(data.token);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  const { delAllView } = useTagsView();
  const logout = () => {
    // 清空store里token
    state.token = "";
    // 清空localStorage里的token
    removeToken();
    // 清除所有tag views
    delAllView();
  };
  const resetToken = () => {
    // 清空store里token
    state.token = "";
    // 清空localStorage里的token
    removeToken();
  };
  // 获取全部用户
  const getAllUsers = async (params: IUserQuery) => {
    const res = await getUsersApi(params);
    const { data } = res;
    state.users = data.users;
    state.count = data.count;
  };
  // 添加用户
  const addUser = async (data: IProfileQuery) => {
    const { pageSize, pageNum, ...params } = data;
    const res = await addUserApi(params);
    if (res.code === 0) {
      getAllUsers({
        pageSize,
        pageNum,
      });
    }
  };
  // 编辑用户
  const editUser = async (data: IProfileQuery) => {
    const { pageSize, pageNum, ...params } = data;
    const res = await updateUserApi(params.id, params);
    if (res.code === 0) {
      getAllUsers({
        pageSize,
        pageNum,
      });
    }
  };
  // 删除用户
  const removeUser = async (data: IProfileQuery) => {
    const { pageSize, pageNum, id } = data;
    const res = await removeUserApi(id);
    if (res.code === 0) {
      getAllUsers({
        pageSize,
        pageNum,
      });
    }
  };
  // 获取用户
  const getUserInfo = async () => {
    const res = await getUserInfoApi();
    const { data } = res;
    const { roles, ...info } = data;
    state.userInfo = info as Profile;
    state.roles = roles;
  };
  return {
    state,
    login,
    logout,
    resetToken,
    getAllUsers, // 获取所有用户
    addUser, // 添加用户
    editUser, // 编辑用户
    removeUser, // 删除用户
    getUserInfo, // 获取用户信息
  };
});
```

### 33.3 用户管理

src/views/system/user/index.vue

```vue
<template>
  <div class="user-container">
    <h2>用户管理</h2>
    <el-form :inline="true" :model="formQuery" ref="queryFormRef">
      <el-form-item label="用户名" prop="username">
        <el-input
          placeholder="请输入用户名"
          v-model="formQuery.username"
        ></el-input>
      </el-form-item>
      <el-form-item label="手机号" prop="mobile">
        <el-input
          placeholder="请输入手机号"
          v-model="formQuery.mobile"
        ></el-input>
      </el-form-item>
      <el-form-item label="状态" prop="status">
        <el-select placeholder="状态" v-model="formQuery.status">
          <el-option label="全部" value="all"></el-option>
          <el-option label="禁用" :value="0"></el-option>
          <el-option label="正常" :value="1"></el-option>
        </el-select>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" plain @click="handleSubmitQuery"
          >查询</el-button
        >
        <el-button type="default" @click="handleResetFields">重置</el-button>
      </el-form-item>
    </el-form>
    <div class="role-list">
      <el-button type="primary" plain @click="handleAddUser">
        <el-icon style="vertical-align: middle">
          <el-icon-plus />
        </el-icon>
        添加用户</el-button
      >
      <el-table :data="users" max-height="400">
        <el-table-column prop="username" label="用户名"> </el-table-column>
        <el-table-column prop="mobile" label="手机"> </el-table-column>
        <el-table-column prop="email" label="邮箱"> </el-table-column>
        <el-table-column prop="status" label="状态" :formatter="formatter">
        </el-table-column>
        <el-table-column prop="createdAt" label="创建时间"> </el-table-column>
        <el-table-column label="操作" fixed="right" width="150px">
          <template #default="scope">
            <el-button
              size="small"
              link
              @click="handleEditUser(scope.$index, scope.row)"
              >编辑</el-button
            >
            <el-button
              size="small"
              link
              @click="handleDeleteUser(scope.$index, scope.row)"
              >删除</el-button
            >
          </template>
        </el-table-column>
      </el-table>
      <div class="user-pagination">
        <el-pagination
          @size-change="handleSizeChange"
          @current-change="handleCurrentChange"
          background
          :total="total"
          :page-sizes="[1, 5, 10, 20]"
          :page-size="pageSize"
          layout="total, prev, pager, next, sizes,jumper"
        ></el-pagination>
      </div>
      <!-- 新增角色 编辑角色面板 -->
      <right-panel v-model="panelVisible" :title="panelTitle" :size="330">
        <editor-user
          :type="editType"
          :data="editData"
          @submit="handleSubmitUser"
        />
      </right-panel>
    </div>
  </div>
</template>

<script lang="ts" setup>
import type { FormInstance } from "element-plus";
import RightPanel from "@/components/RightPanel/index.vue";
import EditorUser from "./components/editorUser.vue";
import { IProfileQuery, useUserStore } from "@/stores/user";
import { IUserQuery, Profile } from "@/api/config/user";
import { useRoleStore } from "@/stores/role";
import { RoleParams } from "@/api/config/role";

const { proxy } = getCurrentInstance()!;
const store = useUserStore();

// 查询表单ref
const queryFormRef = ref<FormInstance | null>(null);

// 查询条件
const formQuery = reactive({
  username: "",
  status: "all",
  mobile: "",
});
// 用户列表
const users = computed(() => store.state.users);
// 用户总条数
const total = computed(() => store.state.count);

// 分页相关状态
const pageNum = ref(0);
const pageSize = ref(1);

// 获取用户列表 支持分页
const getUserList = () => {
  store.getAllUsers({
    pageNum: pageNum.value,
    pageSize: pageSize.value,
    ...formQuery,
  } as unknown as IUserQuery);
};
onMounted(() => {
  // 初始加载数据
  getUserList();
});

// 查询
const handleSubmitQuery = () => {
  getUserList();
};
// 重置
const handleResetFields = () => {
  (queryFormRef.value as FormInstance).resetFields();
  getUserList();
};
// 分页
const handleSizeChange = (val: number) => {
  pageSize.value = val;
  getUserList();
};
const handleCurrentChange = (val: number) => {
  pageNum.value = val - 1; // 页码后端是从0开始的
  getUserList();
};

// 格式化status
const formatter = (row: Profile) => {
  return row.status ? "正常" : "禁用";
};

// 用户新增
const editData = ref<Profile | undefined>(undefined);
// 控制面板显示
const panelVisible = ref(false);
// 操作类型 0编辑 1新增
const editType = ref(1);
// panel title
const panelTitle = computed(() =>
  editType.value === 1 ? "新增用户" : "编辑用户"
);

// 获取角色 添加和编辑用户都需要分配角色 这里是必选
const storeRole = useRoleStore();
storeRole.getRoles({} as RoleParams);
const roles = computed(() => storeRole.state.roles); // 稍后完善

// 添加用户
const handleAddUser = () => {
  editType.value = 1;
  editData.value = {} as Profile;
  editData.value.roles = roles.value!; // 所有角色列表
  editData.value.roleIds = []; // 所选角色id列表
  panelVisible.value = true;
};
// 编辑用户
const handleEditUser = (_index: number, row: Profile) => {
  editType.value = 0;
  editData.value = { ...row };
  // 获取当前编辑用户 现有角色列表
  editData.value.roleIds = row.roles.map((item) => item.id);
  editData.value.roles = roles.value!; // 所有角色列表
  panelVisible.value = true;
};
// 新增用户
const addNewUser = (data: Profile) => {
  store.addUser({
    ...data,
    pageSize: pageSize.value,
    pageNum: pageNum.value,
  });
  (queryFormRef.value as FormInstance).resetFields();
  proxy?.$message.success("用户添加成功");
  panelVisible.value = false;
};
// 编辑用户
const editUser = (data: Profile) => {
  store.editUser({
    ...data,
    pageSize: pageSize.value,
    pageNum: pageNum.value,
  });
  (queryFormRef.value as FormInstance).resetFields();
  proxy?.$message.success("用户编辑成功");
  panelVisible.value = false;
};

// 删除用户
const handleDeleteUser = (_index: number, row: Profile) => {
  proxy
    ?.$confirm(`您确认要删除用户${row.username}吗？`, "删除确认", {
      type: "warning",
    })
    .then(async () => {
      await store.removeUser({
        id: row.id,
      } as IProfileQuery);
      proxy?.$message.success("用户删除成功");
    })
    .catch((err: Error) => {
      console.log("err", err);
      proxy?.$message({
        type: "info",
        message: "已取消删除",
      });
    });
};
// 提交用户信息
const handleSubmitUser = (data: Profile) => {
  if (editType.value === 1) {
    // 新增
    addNewUser(data);
  } else if (editType.value === 0) {
    // 编辑
    editUser(data);
  }
};
</script>

<style lang="scss" scoped>
.user-container {
  padding: 30px;
  .user-pagination {
    margin-top: 10px;
    text-align: right;
  }
}
</style>
```

### 33.4 创建 editorUser 组件

/src/views/system/user/components/editorUser.vue

```vue
<template>
  <div class="editor-container">
    <el-form
      ref="editFormRef"
      :model="editData"
      :rules="menuFormRules"
      label-width="80px"
    >
      <el-form-item label="用户名" prop="username">
        <el-input v-model="editData.username" placeholder="请输入用户名" />
      </el-form-item>
      <el-form-item label="手机" prop="mobile">
        <el-input
          v-model="editData.mobile"
          placeholder="请输入手机"
          maxlength="11"
        />
      </el-form-item>
      <el-form-item label="邮箱" prop="email">
        <el-input v-model="editData.email" placeholder="请输入邮箱" />
      </el-form-item>
      <el-form-item label="状态" prop="status">
        <el-switch v-model="editData.status" />
      </el-form-item>
      <el-form-item label="角色分配" prop="roleIds">
        <el-select multiple v-model="editData.roleIds" placeholder="请选择角色">
          <el-option
            v-for="item in editData.roles"
            :key="item.id"
            :label="item.name"
            :value="item.id"
          >
          </el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="说明" prop="description">
        <el-input
          type="textarea"
          :rows="3"
          v-model="editData.description"
          placeholder="请输入说明"
        />
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="submitMenuForm" :loading="loading"
          >提交</el-button
        >
      </el-form-item>
    </el-form>
  </div>
</template>

<script lang="ts" setup>
import { Profile } from "@/api/config/user";
import type { FormInstance } from "element-plus";
import type { PropType } from "vue";
const props = defineProps({
  type: {
    // 操作类型 0编辑 1新增
    type: Number,
    required: true,
  },
  data: {
    type: Object as PropType<Profile>,
  },
});
const emit = defineEmits(["submit"]);
const loading = ref(false);
const editFormRef = ref<FormInstance | null>(null);
const editData = ref<Partial<Profile>>({
  username: "",
  email: "",
  mobile: "",
  description: "",
  status: true,
});
// 验证规则
const validateMobile = (
  rule: unknown,
  value: string,
  callback: (arg?: Error) => void
) => {
  if (!isNaN(Number(value)) && value.length === 11) {
    callback();
  }
  callback(new Error("请输入正确格式手机号!"));
};

const menuFormRules = {
  username: {
    required: true,
    message: "请输入用户名",
    trigger: "blur",
  },
  email: [
    {
      required: true,
      message: "请输入邮箱",
      trigger: "blur",
    },
    {
      type: "email",
      message: "请输入正确的邮箱地址",
      trigger: ["blur", "change"],
    },
  ],
  mobile: [
    {
      required: true,
      message: "请输入手机",
      trigger: "blur",
    },
    {
      message: "请输入正确11位手机号",
      trigger: "blur",
      validator: validateMobile,
    },
  ],
  roleIds: {
    required: true,
    message: "请至少选择一个角色！",
    // validator: validateRoles,
    trigger: "blur",
  },
};
const defaultProps = {
  username: "",
  email: "",
  mobile: "",
  description: "",
  status: true,
};
watchEffect(() => {
  if (props.data) {
    // 移除之前表单效验结果

    editFormRef.value?.clearValidate();
    editData.value = { ...defaultProps, ...props.data };
  }
});
// 提交编辑菜单
const submitMenuForm = () => {
  (editFormRef.value as FormInstance).validate((valid) => {
    if (valid) {
      emit("submit", editData.value);
    }
  });
};
</script>
<style>
.editor-container {
  padding: 20px;
}
</style>
```

> 修改路由对应的页面

## 34. 角色管理

### 34.1 角色 api

src/api/config/role.ts

```ts
import request from "@/api/config/request";
import { ApiResponse } from "../type";
export interface IRole {
  id: number;
  name: string;
  description: string;
  is_default: boolean;
  createdAt: string;
  updatedAt: string;
}
// 定义state类型
export interface IRoleState {
  roles: IRole[];
  count: number;
}
// 获取角色
export interface RoleParams {
  pageNum: number;
  pageSize: number;
}
export const getRoles = (
  params = { pageNum: 0, pageSize: 10 }
): Promise<ApiResponse<IRoleState>> => {
  return request.get("/role", {
    params,
  });
};
// 删除角色
export const removeRole = (id: number): Promise<ApiResponse> => {
  return request.delete(`/role/${id}`);
};
// 添加角色
export const addRole = (data: IRole): Promise<ApiResponse> => {
  return request.post("/role", data);
};
// 编辑角色
export const updateRole = (id: number, data: IRole): Promise<ApiResponse> => {
  return request.put(`/role/${id}`, data);
};
```

### 34.2 角色相关 store

src/stores/role.ts

```ts
import { IRole, RoleParams } from "@/api/config/role";
import { defineStore } from "pinia";
import {
  getRoles as getRolesApi,
  addRole as addRoleApi,
  updateRole as updateRoleApi,
  removeRole as removeRoleApi,
} from "@/api/config/role";
import { Role } from "@/api/config/user";
export type ActionRoleParams = IRole & {
  pageSize: number;
  pageNum: number;
};
export const useRoleStore = defineStore("role", () => {
  // 状态
  const state = reactive({
    roles: [] as Role[],
    count: 0,
  });
  // 获取角色
  const getRoles = async (params: RoleParams) => {
    const res = await getRolesApi(params);
    const { data } = res;
    state.roles = data.roles;
    state.count = data.count;
  };
  // 添加角色
  const addRole = async (data: ActionRoleParams) => {
    const { pageSize, pageNum, ...params } = data;
    const res = await addRoleApi(params);
    if (res.code === 0) {
      getRoles({ pageSize, pageNum });
    }
  };
  // 编辑角色
  const editRole = async (data: ActionRoleParams) => {
    const { pageSize, pageNum, ...params } = data;
    const res = await updateRoleApi(params.id, params);
    if (res.code === 0) {
      getRoles({ pageSize, pageNum });
    }
  };
  const removeRole = async (data: ActionRoleParams) => {
    const { pageSize, pageNum, id } = data;
    const res = await removeRoleApi(id);
    if (res.code === 0) {
      getRoles({ pageSize, pageNum });
    }
  };
  return { getRoles, addRole, editRole, removeRole };
});
```

### 34.3 角色管理页面

src/views/system/role/index.vue

```vue
<template>
  <div class="role-container">
    <h2>角色管理</h2>
    <div class="role-list">
      <el-button type="primary" plain @click="handleAddRole">
        <el-icon style="vertical-align: middle">
          <el-icon-plus />
        </el-icon>

        添加角色</el-button
      >
      <el-table :data="roles" max-height="400">
        <el-table-column prop="name" label="角色名称"> </el-table-column>
        <el-table-column prop="description" label="说明"> </el-table-column>
        <el-table-column
          prop="is_default"
          label="是否默认角色"
          :formatter="formatter"
        >
        </el-table-column>
        <el-table-column prop="createdAt" label="创建时间"> </el-table-column>
        <el-table-column prop="updatedAt" label="更新时间"> </el-table-column>
        <el-table-column label="操作" fixed="right" width="150px">
          <template #default="scope">
            <el-button
              link
              size="small"
              @click="handleRoleMenu(scope.$index, scope.row)"
            >
              菜单权限
            </el-button>
            <el-button
              size="small"
              link
              @click="handleEditRole(scope.$index, scope.row)"
              >编辑</el-button
            >
            <el-button
              size="small"
              link
              @click="handleDeleteRole(scope.$index, scope.row)"
              >删除</el-button
            >
          </template>
        </el-table-column>
      </el-table>
      <div class="role-pagination">
        <el-pagination
          @size-change="handleSizeChange"
          @current-change="handleCurrentChange"
          background
          :total="total"
          :page-sizes="[5, 10, 20]"
          :page-size="pageSize"
          layout="total, prev, pager, next, sizes,jumper"
        ></el-pagination>
      </div>
    </div>
    <!-- 新增角色 编辑角色面板 -->
    <right-panel v-model="panelVisible" :title="panelTitle" :size="330">
      <editor-role
        :type="editType"
        :data="editData"
        @submit="handleSubmitRole"
      />
    </right-panel>
    <!-- 权限菜单树 -->
    <role-menu
      v-if="roleData && roleMenuVisible"
      :role="roleData"
      v-model="roleMenuVisible"
    />
  </div>
</template>

<script lang="ts" setup>
import { ActionRoleParams, useRoleStore } from "@/stores/role";
import { IRole } from "@/api/config/role";
import EditorRole from "./components/editorRole.vue";

const { proxy } = getCurrentInstance()!;
const store = useRoleStore();
// 角色列表
const roles = computed(() => store.state.roles);
// 总条数
const total = computed(() => store.state.count);
// 分页页码 条数 页码后端是从0开始 前端是从1开始
const pageNum = ref(0);
const pageSize = ref(5);
// 暂存新增和编辑数据
const editData = ref<IRole | undefined>(undefined);
// 编辑面板显示
const panelVisible = ref(false);
// 面板操作类型
const editType = ref(1); // 0编辑 1新增
// panel title
const panelTitle = computed(() =>
  editType.value === 1 ? "新增角色" : "编辑角色"
);

// 获取角色列表
const getRoleList = () => {
  store.getRoles({ pageNum: pageNum.value, pageSize: pageSize.value });
};
// 获取全部菜单
onMounted(() => {
  // store.getAllMenuList()
});
// 自动追踪相关依赖属性变动获取数据
watchEffect(() => {
  getRoleList();
});
// 编辑角色处理
const handleEditRole = (index: number, row: IRole) => {
  editType.value = 0;
  editData.value = { ...row };
  panelVisible.value = true;
};
// 添加角色处理
const handleAddRole = () => {
  editType.value = 1;
  editData.value = {} as IRole;
  panelVisible.value = true;
};

// 删除角色处理
const handleDeleteRole = (index: number, row: IRole) => {
  proxy
    ?.$confirm(`您确认要删除角色${row.name}吗？`, "删除确认", {
      type: "warning",
    })
    .then(async () => {
      await store.removeRole({
        id: row.id,
        pageSize: pageSize.value,
        pageNum: pageNum.value,
      } as ActionRoleParams);
      proxy?.$message.success("角色删除成功");
    })
    .catch(() => {
      proxy?.$message({
        type: "info",
        message: "已取消删除",
      });
    });
};
// 新增角色
const addNewRole = async (data: IRole) => {
  await store.addRole({
    ...data,
    pageSize: pageSize.value,
    pageNum: pageNum.value,
  });
  proxy?.$message.success("角色添加成功");
  panelVisible.value = false;
};
// 编辑角色
const editRole = async (data: IRole) => {
  await store.editRole({
    ...data,
    pageSize: pageSize.value,
    pageNum: pageNum.value,
  });
  proxy?.$message.success("角色编辑成功");
  panelVisible.value = false;
};

// 提交角色信息
const handleSubmitRole = (data: IRole) => {
  if (editType.value === 1) {
    // 新增
    addNewRole(data);
  } else if (editType.value === 0) {
    // 编辑
    editRole(data);
  }
};

// 权限菜单处理
const roleMenuVisible = ref(false);
const roleData = ref<IRole | null>(null);
const handleRoleMenu = (index: number, row: IRole) => {
  roleMenuVisible.value = true;
  roleData.value = row;
};

const formatter = (row: IRole) => {
  return row.is_default ? "是" : "否";
};
// pageSize 改变
const handleSizeChange = (val: number) => {
  pageSize.value = val;
};
// pageNum 改变
const handleCurrentChange = (val: number) => {
  pageNum.value = val - 1; // 页码后端是从0开始的
};
</script>

<style lang="scss" scoped>
.role-container {
  padding: 30px;
  .role-pagination {
    margin-top: 10px;
    text-align: right;
  }
}
</style>
```

### 34.4 editorRole 组件

src/views/system/role/components/editorRole.vue

```vue
<template>
  <div class="editor-container">
    <el-form
      ref="editFormRef"
      :model="editData"
      :rules="menuFormRules"
      label-width="100px"
    >
      <el-form-item label="角色名称" prop="name">
        <el-input v-model="editData.name" placeholder="请输入角色名称" />
      </el-form-item>
      <el-form-item label="说明" prop="description">
        <el-input v-model="editData.description" placeholder="请输入说明" />
      </el-form-item>
      <el-form-item label="是否默认角色" prop="is_default">
        <el-switch
          :active-value="1"
          :inactive-value="0"
          v-model="editData.is_default"
        />
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="submitMenuForm" :loading="loading"
          >提交</el-button
        >
      </el-form-item>
    </el-form>
  </div>
</template>

<script lang="ts" setup>
import type { PropType } from "vue";
import { ElForm } from "element-plus";
import { IRole } from "@/api/config/role";

type FormInstance = InstanceType<typeof ElForm>;

const emit = defineEmits(["submit"]);
const props = defineProps({
  type: {
    type: Number,
    required: true,
  },
  data: {
    type: Object as PropType<IRole>,
  },
});

const loading = ref(false);
const editFormRef = ref<FormInstance | null>(null);
const editData = ref({
  name: "",
  description: "",
  is_default: false,
});

// 验证规则
const menuFormRules = {
  name: {
    required: true,
    message: "请输入角色名称",
    trigger: "blur",
  },
  description: {
    required: true,
    message: "请输入说明",
    trigger: "blur",
  },
};

const defaultProps = {
  name: "",
  description: "",
  is_default: false,
};

watchEffect(() => {
  // 利用watchEffect自动响应依赖变化
  if (props.data) {
    // 移除之前表单效验结果
    editFormRef.value?.clearValidate();
    editData.value = { ...defaultProps, ...props.data };
  }
});

// 提交编辑菜单
const submitMenuForm = () => {
  (editFormRef.value as FormInstance).validate((valid) => {
    if (valid) {
      emit("submit", editData.value);
    }
  });
};
console.log(editData);
</script>

<style>
.editor-container {
  padding: 20px;
}
</style>
```

## 35. 菜单管理

### 35.1 菜单 api

src/api/config/menu.ts

```ts
import request from "./request";
import { ApiResponse } from "../type";
export interface MenuData {
  id: number;
  title: string;
  path: string;
  name: string;
  icon: string;
  parent_id: string | number;
  sort_id: number;
}
// 添加新菜单
export const addNewMenu = (
  data: Omit<MenuData, "id">
): Promise<ApiResponse> => {
  return request.post("/access/menu", data);
};
// 获取全部菜单
export const getAllMenus = (): Promise<ApiResponse<MenuData[]>> => {
  return request.get("/access/menu");
};
// 删除指定菜单
export const removeMenuByID = (id: number): Promise<ApiResponse<null>> => {
  return request.delete(`/access/menu/${id}`);
};
// 更新指定菜单
type UpdateMenuData = Omit<MenuData, "id" | "parent_id" | "sort_id">;
export const updateMenuByID = (
  id: number,
  data: UpdateMenuData
): Promise<ApiResponse<null>> => {
  return request.put(`/access/menu/${id}`, data);
};
// 批量更新菜单
export const updateBulkMenu = (
  data: MenuData[]
): Promise<ApiResponse<null>> => {
  return request.patch("/access/menu/update", {
    access: data,
  });
};
```

### 35.2 角色菜单 api

src/api/config/roleAccess.ts

```ts
import request from "@/api/config/request";
import { MenuData } from "./menu";
import { ApiResponse } from "../type";
import { IRole } from "./role";
export interface IRoleAccess {
  id: number;
  role_id: number;
  access_id: number;
}
export type IRoleAccessList = IRoleAccess[];
/**
 * 根据角色分配权限
 * @param id 角色id
 * @param data 权限id列表
 */
export const allocRoleAccess = (
  id: number,
  data: number[]
): Promise<ApiResponse> => {
  return request.post(`/role_access/${id}`, {
    access: data,
  });
};
/**
 * 根据角色获取权限
 * @param id 角色id
 * @param data 权限id列表
 */
export const getRoleAccess = (
  id: number
): Promise<ApiResponse<IRoleAccessList>> => {
  return request.get(`/role_access/${id}`);
};
// 根据用户角色获取用户菜单
type RolesAccess = MenuData & {
  roles: IRole[];
};
interface ApiRolesAccess {
  access: RolesAccess[];
}
export const getAccessByRoles = (
  roles: number[]
): Promise<ApiResponse<ApiRolesAccess>> => {
  return request.post("/role_access/role/access", {
    roles,
  });
};
```

### 35.3 菜单相关 store

src/stores/menu.ts

```ts
import { getAllMenus as getAllMenusApi } from "@/api/config/menu";
import { getAccessByRoles as getAccessByRolesApi } from "@/api/config/roleAccess";
import { MenuData } from "@/api/config/menu";
import { defineStore } from "pinia";
import { generateMenuTree, generateTree } from "@/utils/generateTree";
export interface ITreeItemData extends MenuData {
  children?: ITreeItemData[];
}
// state类型
export interface IMenusState {
  menuTreeData: Array<ITreeItemData>; // 树形菜单数据
  menuList: Array<MenuData>; // 原始菜单列表数据
  authMenuTreeData: Array<ITreeItemData>; // 树形菜单数据
  authMenuList: Array<MenuData>; // 原始菜单列表数据
}
export const useMenuStore = defineStore("menu", () => {
  const state = reactive<IMenusState>({
    menuTreeData: [],
    menuList: [],
    authMenuTreeData: [],
    authMenuList: [],
  });
  const getAllMenuList = async () => {
    const response = await getAllMenusApi();
    const { data } = response;
    state.menuList = data; // 获取的菜单列表
    const treeData = generateTree([...data]); // 生成树数据
    state.menuTreeData = treeData; // 格式化后菜单树数据
  };
  const getAllMenuListByAdmin = async () => {
    const response = await getAllMenusApi();
    const { data } = response;
    state.authMenuList = data; // 权限菜单列表
    const treeData = generateMenuTree([...data]);
    state.authMenuTreeData = treeData; // 权限菜单树数据
  };
  const getAccessByRoles = async (roles: number[]) => {
    const response = await getAccessByRolesApi(roles);
    const { access } = response.data;
    const treeData = generateMenuTree([...access]);
    state.authMenuTreeData = treeData;
  };
  return { state, getAllMenuList, getAllMenuListByAdmin, getAccessByRoles };
});
```

### 35.4 生成 Tree 方法

src/utils/generateTree.ts

```ts
import { MenuData } from "@/api/config/menu";
export interface ITreeItemData extends MenuData {
  children?: ITreeItemData[];
}
type IMap = Record<number | string, ITreeItemData>;
const generateTree = (list: MenuData[]): ITreeItemData[] => {
  // 生成一个map key为id value为当前对象
  const map = list.reduce((prev, cur) => {
    const temp = { ...cur };
    prev[cur.id as number] = temp;
    return prev;
  }, {} as IMap);
  const tree: ITreeItemData[] = [];
  list.forEach((item) => {
    const temp = map[item.id as number];
    const pid = temp.parent_id;
    if ((pid != null || pid !== 0) && map[pid]) {
      const parent = map[pid];
      if (!parent.children) parent.children = [];
      parent.children.push(temp);
      return;
    }
    tree.push(temp);
  });
  return tree;
};
type ITreeItemDataWithMeta = ITreeItemData & {
  meta?: {
    icon: string;
    title: string;
  };
};
type IMapWithMeta = Record<number | string, ITreeItemDataWithMeta>;
const generateMenuTree = (list: MenuData[]): ITreeItemData[] => {
  // 生成一个map key为id value为当前对象
  const map = list.reduce((prev, cur) => {
    const temp = { ...cur };
    prev[cur.id as number] = temp;
    return prev;
  }, {} as IMapWithMeta);
  const tree: ITreeItemData[] = [];
  list.forEach((item) => {
    const temp = map[item.id as number];
    temp.meta = {
      title: temp.title,
      icon: temp.icon,
    };
    const pid = temp.parent_id;
    if ((pid != null || pid !== 0) && map[pid]) {
      const parent = map[pid];
      if (!parent.children) parent.children = [];
      parent.children.push(temp);
      return;
    }
    tree.push(temp);
  });
  return tree;
};
export { generateTree, generateMenuTree };
```

### 35.5 菜单管理页面

src/views/system/menu/index.vue

```vue
<template>
  <div class="menu-container">
    <!-- 菜单树 -->
    <el-card class="tree-card">
      <template #header>
        <el-button @click="handleCreateRootMenu">新增顶级菜单</el-button>
      </template>
      <div class="block">
        <div class="menu-tree">
          <el-tree
            ref="menuTreeRef"
            :data="menus"
            highlight-current
            node-key="id"
            :expand-on-click-node="false"
            :check-strictly="true"
            @node-click="handleNodeClick"
            :props="defaultProps"
            draggable
            :allow-drop="allowDrop"
            :allow-drag="allowDrag"
            @node-drop="handleNodeDrop"
          >
            <template #default="{ node, data }">
              <span class="custom-tree-node">
                <span>{{ node.label }}</span>
                <span>
                  <el-button link @click.stop="handleCreateChildMenu(data)">
                    添加
                  </el-button>
                  <el-button link @click.stop="handleRemoveMenu(node, data)">
                    删除
                  </el-button>
                </span>
              </span>
            </template>
          </el-tree>
        </div>
      </div>
    </el-card>
    <el-card class="edit-card">
      <template #header> 编辑菜单 </template>
      <editor-menu v-show="editData && editData.id" :data="editData" />
      <span v-if="editData == null">从菜单列表选择一项后，进行编辑</span>
    </el-card>
    <!-- 添加菜单 -->
    <right-panel v-model="dialogVisible" :title="panelTitle">
      <div class="menu-form">
        <el-form
          ref="menuFormRef"
          :model="menuFormData"
          :rules="menuFormRules"
          label-width="100px"
        >
          <el-form-item label="菜单名称" prop="title">
            <el-input
              v-model="menuFormData.title"
              placeholder="请输入菜单名称"
            />
          </el-form-item>
          <el-form-item label="路径" prop="path">
            <el-input
              v-model="menuFormData.path"
              placeholder="请输入路由路径"
            />
          </el-form-item>
          <el-form-item label="路由Name" prop="name">
            <el-input
              v-model="menuFormData.name"
              placeholder="请输入路由名称"
            />
          </el-form-item>
          <el-form-item label="图标" prop="icon">
            <el-input
              v-model="menuFormData.icon"
              placeholder="请输入icon名称"
            />
          </el-form-item>
          <el-form-item>
            <el-button type="primary" @click="submitMenuForm"
              >创建菜单</el-button
            >
          </el-form-item>
        </el-form>
      </div>
    </right-panel>
  </div>
</template>
<script lang="ts" setup>
import type { FormInstance as IMenuForm } from "element-plus";
import { addNewMenu, removeMenuByID, updateBulkMenu } from "@/api/config/menu";
import { useMenuStore } from "@/stores/menu";
import EditorMenu from "./components/editorMenu.vue";
import { ITreeItemData } from "@/utils/generateTree";
import { MenuData } from "@/api/config/menu";
import { useReloadPage } from "@/hooks/useReload";

interface ITreeNode {
  id: number;
  title: string;
  children: ITreeNode[];
  parentId?: number;
  sortId: number;
  parent: {
    data: ITreeNode;
  };
  data: ITreeItemData;
}

type IMenuItemNotID = Omit<ITreeItemData, "id">;
const store = useMenuStore();
const { proxy } = getCurrentInstance()!;
const treeData = computed(() => store.state.menuTreeData);
const menus = ref<ITreeItemData[]>([]);
const editData = ref<MenuData>();
watch(treeData, (value: ITreeItemData[]) => {
  menus.value = JSON.parse(JSON.stringify(value));
  editData.value = undefined;
});

onMounted(() => {
  // 获取全部菜单
  store.getAllMenuList();
});

// tree props
const defaultProps = ref({
  children: "children",
  label: "title",
});
// 重新刷新整个系统
const { reloadPage } = useReloadPage();

// 添加菜单panel
const dialogVisible = ref(false);
watch(dialogVisible, (value) => {
  if (!value) {
    (menuFormRef.value as IMenuForm).resetFields();
  }
});

// 分配sortId 根据最后一个数据sortId+1
const getMenuNodeSortID = (list: ITreeItemData[]) => {
  if (list && list.length > 0) {
    return list[list.length - 1].sort_id + 1;
  }
  return 0;
};
// 移除节点
const removeNode = (node: ITreeNode, childId: number) => {
  const parent = node.parent;
  const children = parent.data.children || parent.data;
  const index = children.findIndex((d) => d.id === childId);
  children.splice(index, 1);
  menus.value = [...menus.value];
};

/**
 * node: 当前node对象
 * menuData: 当前节点数据
 */
const handleRemoveMenu = (node: ITreeNode, menuData: ITreeItemData) => {
  proxy
    ?.$confirm(`您确认要删除菜单${menuData.title}吗？`, "删除确认", {
      type: "warning",
    })
    .then(async () => {
      // 根据id删除菜单
      const res = await removeMenuByID(menuData.id);
      if (res.code === 0) {
        proxy?.$message.success("删除成功");
        removeNode(node, menuData.id);
        // 如果删除的是当前编辑的菜单 就重置编辑表单
        if (editData.value && menuData.id === editData.value.id) {
          editData.value = undefined;
        }
        // 是否重新刷新整个系统
        reloadPage();
      }
    })
    .catch(() => {
      proxy?.$message({
        type: "info",
        message: "已取消删除",
      });
    });
};

// 新增顶级菜单
// 添加菜单表单
const menuFormRef = ref<IMenuForm | null>(null);
// 菜单表单数据
const menuFormData = reactive<IMenuItemNotID>({
  title: "",
  path: "",
  name: "",
  icon: "",
  parent_id: "",
  sort_id: 0,
});
const menuType = ref(0); // 添加菜单类型 0顶级 1子级
// 面板title
const panelTitle = computed(() =>
  menuType.value === 0 ? "添加顶级菜单" : "添加子菜单"
);
// 重置添加菜单状态
const resetStatus = () => {
  dialogVisible.value = false;
  menuFormRef.value?.resetFields();
  parentData.value = null;
};
// ············· 添加顶级菜单 ······················
// 点击添加顶级菜单
const handleCreateRootMenu = () => {
  menuType.value = 0;
  dialogVisible.value = true;
};

// 顶级菜单分配partentId和sortId
const allocRootMenuId = (data: IMenuItemNotID) => {
  const sortId = getMenuNodeSortID(menus.value);
  data.sort_id = sortId;
  data.parent_id = "0";
};
// 顶级菜单 添加到 tree组件中
const appendRootMenu = (id: number, data: IMenuItemNotID) => {
  const node = { id, ...data, children: [] };
  menus.value.push(node);
  menus.value = [...menus.value];
};
// 添加顶级菜单
const handleAddRootMenu = async (data: IMenuItemNotID) => {
  allocRootMenuId(data);
  const res = await addNewMenu(data);
  if (res.code === 0) {
    const { id } = res.data as { id: number };
    appendRootMenu(id, data);
    proxy?.$message.success("菜单创建成功");
    // 是否重新刷新整个系统
    // reloadPage()
  }
};

// ············· 添加子菜单 ······················
// 子菜单分配sortid 和 parentId
const allocChildMenuId = (
  data: IMenuItemNotID,
  parentData: ITreeItemData
): IMenuItemNotID => {
  const pid = parentData.id as number;
  let sortId = 0;
  if (!parentData.children) {
    parentData.children = [];
  }
  if (parentData.children.length > 0) {
    sortId = getMenuNodeSortID(parentData.children);
  }
  data.sort_id = sortId;
  data.parent_id = pid;
  return data;
};
// 添加子菜单到tree组件中
const appendChildMenu = (child: ITreeItemData, parentData: ITreeItemData) => {
  parentData.children!.push(child);
  menus.value = [...menus.value];
};

// 添加子菜单
const parentData = ref<ITreeItemData | null>(null); // 缓存父菜单data
const handleAddChildMenu = async (data: IMenuItemNotID) => {
  const child = allocChildMenuId(data, parentData.value!);
  const res = await addNewMenu(data);
  if (res.code === 0) {
    const { id } = res.data as { id: number };
    (child as ITreeItemData).id = id;
    appendChildMenu(child as ITreeItemData, parentData.value!);
    proxy?.$message.success("菜单创建成功");
    // 是否重新刷新整个系统
    reloadPage();
  }
};
// 新增子菜单
const handleCreateChildMenu = (data: ITreeItemData) => {
  menuType.value = 1;
  dialogVisible.value = true;
  parentData.value = data;
};
// 菜单编辑
const handleNodeClick = (data: MenuData) => {
  editData.value = { ...data };
};

// 提交menuForm
const submitMenuForm = () => {
  (menuFormRef.value as IMenuForm).validate(async (valid) => {
    if (valid) {
      if (menuType.value === 0) {
        // 添加根菜单
        await handleAddRootMenu({ ...menuFormData });
      } else if (menuType.value === 1) {
        // 添加子菜单
        await handleAddChildMenu({ ...menuFormData });
      }
      // 重置相关状态
      resetStatus();
    }
  });
};

// 实现顶级菜单 拖拽排序
// 拖拽一级节点

const allowDrag = (draggingNode: ITreeNode) => {
  const data = draggingNode.data;
  return data.parent_id === 0 || data.parent_id == null;
};
// 拖放一级节点
type DropType = "before" | "after" | "inner";
const allowDrop = (
  _draggingNode: ITreeNode,
  dropNode: ITreeNode,
  type: DropType
) => {
  if (dropNode.data.parent_id === 0 || dropNode.data.parent_id == null) {
    return type !== "inner";
  }
};
// 拖放完成事件
const handleNodeDrop = async () => {
  menus.value.forEach((menu, index) => {
    menu.sort_id = index;
  });
  // 批量更新菜单状态 这里是为了更新sort_id
  const menuList = menus.value.map((menu) => {
    const temp = { ...menu };
    delete temp.children;
    return temp;
  });
  // 批量更新
  await updateBulkMenu(menuList);
};

// 验证规则
const menuFormRules = reactive({
  title: {
    required: true,
    message: "请输入菜单名称",
    trigger: "blur",
  },
  path: {
    required: true,
    message: "请输入路由路径",
    trigger: "blur",
  },
  name: {
    required: true,
    message: "请输入路由名称",
    trigger: "blur",
  },
});
</script>
<style lang="scss">
.menu-container {
  display: flex;
  padding: 20px;
  justify-content: space-around;
  .menu-tree {
    height: 400px;
    overflow-y: scroll;
  }
  .tree-card {
    min-width: 500px;
    padding-bottom: 30px;
  }
  .edit-card {
    flex: 1;
    margin-left: 15px;
  }
  .el-form-item__content {
    min-width: 220px;
  }
  .custom-tree-node {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 14px;
    padding-right: 8px;
  }
  .menu-form {
    padding: 20px 10px 20px 0;
    box-sizing: border-box;
  }
}
</style>
```

src/hook/useReload.ts

```ts
import { getCurrentInstance } from "vue";
interface ReloadFn {
  reloadPage: (title?: string, message?: string) => void;
}
export const useReloadPage = (): ReloadFn => {
  const { proxy } = getCurrentInstance()!;
  const reloadPage = (title = "刷新确认", message?: string) => {
    proxy
      ?.$confirm(message || "菜单已发生改动，是否要刷新当前系统", title, {
        type: "warning",
      })
      .then(() => {
        window.location.reload();
      })
      .catch(() => {
        proxy?.$message({
          type: "info",
          message: "已取消刷新",
        });
      });
  };
  return {
    reloadPage,
  };
};
```

### 35.6 editorMenu 组件

src/views/system/menu/components/editorMenu.vue

```vue
<template>
  <div class="editor-container">
    <el-form
      ref="editFormRef"
      :model="editData"
      :rules="menuFormRules"
      label-width="100px"
    >
      <el-form-item label="菜单名称" prop="title">
        <el-input v-model="editData.title" placeholder="请输入菜单名称" />
      </el-form-item>
      <el-form-item label="路径" prop="path">
        <el-input v-model="editData.path" placeholder="请输入路由路径" />
      </el-form-item>
      <el-form-item label="路由Name" prop="name">
        <el-input v-model="editData.name" placeholder="请输入路由名称" />
      </el-form-item>
      <el-form-item label="图标" prop="icon">
        <el-input v-model="editData.icon" placeholder="请输入icon名称" />
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="submitMenuForm" :loading="loading"
          >编辑菜单</el-button
        >
        <el-button @click="submitReset">重置</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>
<script lang="ts" setup>
import { FormInstance } from "element-plus";
import { MenuData, updateMenuByID } from "@/api/config/menu";
import { useMenuStore } from "@/stores/menu";
import { useReloadPage } from "@/hook/useReload";
import { PropType } from "vue";
const props = defineProps({
  data: {
    type: Object as PropType<MenuData>,
  },
});
defineEmits(["updateEdit"]);
const store = useMenuStore();
const { proxy } = getCurrentInstance()!;
const loading = ref(false);
const editFormRef = ref<FormInstance | null>(null);
const editData = ref({
  id: "",
  title: "",
  name: "",
  path: "",
  icon: "",
});
// 验证规则
const menuFormRules = {
  title: {
    required: true,
    message: "请输入菜单名称",
    trigger: "blur",
  },
  path: {
    required: true,
    message: "请输入路由路径",
    trigger: "blur",
  },
  name: {
    required: true,
    message: "请输入路由名称",
    trigger: "blur",
  },
};
const resetFormData = (data: MenuData) => {
  if (data) {
    const { id, title, name, path, icon } = data;
    editData.value = { id: String(id), title, name, path, icon };
  }
};
watch(
  () => props.data,
  (value) => {
    if (value) {
      resetFormData(value);
    }
  }
);
// 刷新系统
const { reloadPage } = useReloadPage();
// 提交编辑菜单
const submitMenuForm = () => {
  (editFormRef.value as FormInstance).validate((valid) => {
    if (valid) {
      loading.value = true;
      updateMenuByID(Number(editData.value.id), editData.value)
        .then((res) => {
          if (res.code === 0) {
            proxy?.$message.success("菜单编辑成功");
            // 重新获取菜单
            store.getAllMenuList();
            reloadPage();
          }
        })
        .finally(() => {
          loading.value = false;
        });
    }
  });
};
// 重置编辑菜单
const submitReset = () => {
  resetFormData(props.data as MenuData);
};
</script>
```

## 36. 接入权限配置

### 36.1 配置路由

src/router/index.ts

```ts
import { createRouter, createWebHistory, RouteRecordRaw } from "vue-router";
import Layout from "@/layout/index.vue";

export const asyncRoutes: Array<RouteRecordRaw> = [
  {
    path: "/documentation",
    component: Layout, // 布局组件作为一级路由
    redirect: "/documentation/index",
    children: [
      {
        path: "index",
        name: "Documentation",
        component: () =>
          import(
            /* webpackChunkName: "documentation" */ "@/views/documentation/index.vue"
          ),
        meta: {
          title: "Documentation",
          icon: "documentation",
        },
      },
    ],
  },
  {
    path: "/guide",
    component: Layout,
    redirect: "/guide/index",
    children: [
      {
        path: "index",
        name: "Guide",
        component: () =>
          import(/* webpackChunkName: "guide" */ "@/views/guide/index.vue"),
        meta: {
          title: "Guide",
          icon: "guide",
          // 默认加载Guide时，/documentation/index高亮显示
          activeMenu: "/documentation/index",
        },
      },
    ],
  },
  {
    path: "/system",
    component: Layout,
    redirect: "/system/user",
    meta: {
      title: "System",
      icon: "lock",
    },
    children: [
      {
        path: "menu",
        name: "Menu Management",
        component: () =>
          import(
            /* webpackChunkName: "menu" */ "@/views/system/menu/index.vue"
          ),
        meta: {
          title: "Menu Management",
        },
      },
      {
        path: "role",
        name: "Role Management",
        component: () =>
          import(
            /* webpackChunkName: "role" */ "@/views/system/role/index.vue"
          ),
        meta: {
          title: "Role Management",
        },
      },
      {
        path: "user",
        name: "User Management",
        component: () =>
          import(
            /* webpackChunkName: "user" */ "@/views/system/user/index.vue"
          ),
        meta: {
          title: "User Management",
        },
      },
    ],
  },
  {
    // 外链路由
    path: "/external-link",
    component: Layout,
    children: [
      {
        path: "http://www.zhufengpeixun.com/",
        redirect: "/",
        meta: {
          title: "External Link",
          icon: "link",
        },
      },
    ],
  },
  {
    // 这里我们将匹配全部路由，放到异步路由中。
    path: "/:pathMatch(.*)*",
    redirect: "/404",
    meta: {
      hidden: true,
    },
  },
];

const constantRoutes: Array<RouteRecordRaw> = [
  {
    path: "/",
    component: Layout,
    redirect: "/dashboard",
    children: [
      {
        path: "dashboard",
        name: "Dashboard",
        component: () =>
          import(
            /* webpackChunkName: "dashboard" */ "@/views/dashboard/index.vue"
          ),
        meta: {
          title: "Dashboard",
          icon: "dashboard",
          affix: true,
        },
      },
    ],
  },
  {
    path: "/redirect",
    component: Layout,
    meta: {
      hidden: true,
    },
    children: [
      {
        // 带参数的动态路由正则匹配 文档说明
        // https://next.router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E5%8F%82%E6%95%B0
        path: "/redirect/:path(.*)", // 要匹配多级路由 应该加*号
        component: () => import("@/views/redirect/index.vue"),
      },
    ],
  },
  {
    path: "/404",
    component: () => import("@/views/error-page/404.vue"),
    meta: {
      hidden: true, // 404 hidden掉
    },
  },
  {
    path: "/login",
    name: "Login",
    component: () => import("@/views/login/index.vue"),
  },
  // {
  //   path: '/profile',
  //   component: Layout,
  //   redirect: '/profile/index',
  //   name: 'ProfileLayout',
  //   children: [
  //     {
  //       path: 'index',
  //       name: 'Profile',
  //       component: () => import('@/views/profile/index.vue'),
  //       meta: {
  //         hidden: true,
  //         title: '个人中心'
  //       }
  //     }
  //   ]
  // }
];
export const routes = constantRoutes; // 默认只绑定常量路由

export default createRouter({
  history: createWebHistory(),
  routes,
});
```

### 36.2 修改 src/permission.ts

> 先判断是否 有 token 如果有 判断目前有没有角色，没有就根据 token 去获取用户信息包含角
> 色信息 然后根据用户角色获取权限菜单 然后在根据权限菜单 筛选 asyncRoutes 注册相应的权
> 限路由 并渲染返回的菜单

src/permission.ts

```ts
import router from "@/router";
import { ElMessage } from "element-plus";
import nProgress from "nprogress";
import "nprogress/nprogress.css"; // progress bar style
import { usePermissionStore } from "./stores/permission";
import { useUserStore } from "./stores/user";
import { getToken } from "./utils/auth";
nProgress.configure({ showSpinner: false });
const whiteList = ["/login"]; // 白名单
router.beforeEach(async (to) => {
  const userStore = useUserStore();
  const permissionStore = usePermissionStore();
  nProgress.start();
  const hasToken = getToken();
  if (hasToken) {
    // 有token代表已登录
    if (to.path === "/login") {
      nProgress.done();
      return {
        path: "/",
        replace: true,
      };
    } else {
      try {
        const hasRoles =
          userStore.state.roles && userStore.state.roles.length > 0;
        if (hasRoles) {
          // 有权限
          nProgress.done();
          return true;
        }
        // 无用户信息和角色信息 就请求获取
        await userStore.getUserInfo();
        const roles = userStore.state.roles;
        // 该用户未分配角色 进行异常提示
        if (!roles || roles.length === 0) {
          throw new Error("该用户未分配角色");
        }
        // 获取权限路由
        const accessRoutes = await permissionStore.generateRoutes();
        // 动态注册路由
        accessRoutes.forEach(router.addRoute);
        return router.push(to.path);
        // 触发重定向
      } catch (error: any) {
        await userStore.resetToken();
        ElMessage.error("登录失败：" + (error.message || "Has Error"));
        nProgress.done();
        return `/login?redirect=${to.path}`;
      }
      // 有token 看下是否获取过权限
    }
  } else {
    // 没token 返回login
    if (whiteList.includes(to.path)) {
      nProgress.done();
      return true;
    }
    nProgress.done();
    return {
      path: "/login",
      query: {
        redirect: to.path,
        ...to.query,
      },
    };
  }
});
router.afterEach(() => {
  nProgress.done();
});
```

### 36.3 permissions store

src/stores/permission.ts

```ts
import { RouteRecordRaw } from "vue-router";
import path from "path-browserify";
import { defineStore } from "pinia";

import { asyncRoutes } from "@/router";
import { useMenuStore } from "./menu";
import { MenuData } from "@/api/config/menu";
import { useUserStore } from "./user";

// 定义state类型
export interface IPermissionState {
  routes: Array<RouteRecordRaw>;
  accessRoutes: Array<RouteRecordRaw>;
}
const generateRoutePaths = (menus: Array<MenuData>): string[] => {
  return menus.map((menu) => menu.path);
};
// 生成可访问路由表

const whiteList = ["/:pathMatch(.*)*"];
// 生成可访问路由表
const generateRoutes = (
  routes: Array<RouteRecordRaw>,
  routePaths: string[],
  basePath = "/"
) => {
  const routerData: Array<RouteRecordRaw> = [];
  routes.forEach((route) => {
    const routePath = path.resolve(basePath, route.path);
    if (route.children) {
      // 先看子路由 是否有匹配上的路由
      route.children = generateRoutes(route.children, routePaths, routePath);
    }

    // 如果当前路由子路由 数量大于0有匹配上 或 paths中包含当面路由path 就需要把当前父路由添加上

    if (
      routePaths.includes(routePath) ||
      (route.children && route.children.length >= 1) ||
      whiteList.includes(routePath)
    ) {
      routerData.push(route);
    }
  });
  return routerData;
};
const filterAsyncRoutes = (
  menus: Array<MenuData>,
  routes: Array<RouteRecordRaw>
) => {
  // 生成要匹配的路由path数组
  const routePaths = generateRoutePaths(menus);

  // 生成匹配path的路由表
  const routerList = generateRoutes(routes, routePaths);

  return routerList;
};

export const usePermissionStore = defineStore("permission", () => {
  // 状态
  const state = reactive<IPermissionState>({
    routes: [],
    accessRoutes: [],
  });
  const menuStore = useMenuStore();
  const userStore = useUserStore();
  const generateRoutes = async (type?: number) => {
    // 1 针对菜单排序更新

    let accessedRoutes: Array<RouteRecordRaw> = [];
    const roleNames = computed(() => {
      return userStore.state.roles!.map((item) => item.name);
    });

    const roleIds = computed(() => {
      return userStore.state.roles!.map((item) => item.id);
    });

    if (roleNames.value.includes("super_admin")) {
      // 超级管理员角色
      accessedRoutes = asyncRoutes;
      await menuStore.getAllMenuListByAdmin();
      return accessedRoutes;
    } else {
      // 根据角色过滤菜单, 这里修改下getAccessByRoles返回值
      const menus = await menuStore.getAccessByRoles(roleIds.value);
      if (type !== 1) {
        accessedRoutes = filterAsyncRoutes(
          menus as unknown as MenuData[],
          asyncRoutes
        );
      }
      return accessedRoutes;
    }
  };
  return { generateRoutes, state };
});
```

### 36.4 拖拽更新顺序

src/views/system/menu/index.vue

```ts
<script lang='ts' setup>
const permissionStore = usePermissionStore()
// 拖放完成事件
const handleNodeDrop = async () => {
  menus.value.forEach((menu, index) => {
    menu.sort_id = index
  })
  // 批量更新菜单状态 这里是为了更新sort_id
  const menuList = menus.value.map((menu) => {
    const temp = { ...menu }
    delete temp.children
    return temp
  })
  // 批量更新
  const res = await updateBulkMenu(menuList)
  if (res.code === 0) {
    // 重新生成菜单 1 代表是菜单排序更新
    permissionStore.generateRoutes(1)
  }
}
</script>
```

### 36.5 角色菜单分配

src/views/system/role/index.vue

```vue
<template>
  <div class="role-container">
    <!-- .... -->
    <!-- 权限菜单树 -->
    <role-menu
      v-if="roleData && roleMenuVisible"
      :role="roleData"
      v-model="roleMenuVisible"
    />
  </div>
</template>
<script lang="ts" setup>
const menuStore = useMenuStore();
// 获取全部菜单
onMounted(() => {
  menuStore.getAllMenuList();
});
</script>
```

src/views/system/role/components/roleMenu.vue

```vue
<template>
  <div v-if="modelValue">
    <el-dialog v-model="dialogVisible" :title="dialogTitle">
      <el-tree
        :data="treeData"
        show-checkbox
        default-expand-all
        node-key="id"
        ref="menuTree"
        highlight-current
        :check-strictly="checkStrictly"
        :props="defaultProps"
      >
      </el-tree>
      <template #footer>
        <span class="dialog-footer">
          <el-button type="primary" plain @click="handleCheckAll"
            >全部选择</el-button
          >
          <el-button type="primary" @click="handleSubmit">提交</el-button>
        </span>
      </template>
    </el-dialog>
  </div>
</template>

<script lang="ts" setup>
import { IRole } from "@/api/config/role";
import { useMenuStore as useStore } from "@/stores/menu";
import { ElTree } from "element-plus";
import { allocRoleAccess, getRoleAccess } from "@/api/config/roleAccess";
import { useReloadPage } from "@/hooks/useReload";
import { PropType } from "vue";

type ElTreeInstance = InstanceType<typeof ElTree>;
const props = defineProps({
  modelValue: {
    type: Boolean,
    default: false,
  },
  role: {
    type: Object as PropType<IRole>,
    required: true,
  },
});
const emit = defineEmits(["update:modelValue"]);

const { proxy } = getCurrentInstance()!;
const store = useStore();
const menuTree = ref<ElTreeInstance | null>(null);
const role = props.role as IRole;
const dialogVisible = ref(true);
const defaultProps = ref({
  children: "children",
  label: "title",
});
// tree父节点与子节点是否强关联
const checkStrictly = ref(false); // false关联 true不关联
const dialogTitle = computed(() => `分配 ${role.name} 菜单权限`);
const treeData = computed(() => store.state.menuTreeData);

watch(dialogVisible, (value) => {
  emit("update:modelValue", value);
});

// 发送选中key与role id关联请求
const handleRoleWithMenu = (keys: number[], roleId: number) => {
  // 发送关联请求
  allocRoleAccess(roleId, keys).then((res) => {
    if (res.code === 0) {
      proxy?.$message.success(res.message);
      emit("update:modelValue", false);
      reloadPage();
    }
  });
};

// 重新刷新整个系统
const { reloadPage } = useReloadPage();

// 提交选择的菜单和当前角色做关联
const handleSubmit = () => {
  const tree = menuTree.value as ElTreeInstance;
  // 获取所有checkbox全选节点key 这里key是菜单id
  const keys = tree.getCheckedKeys(false);
  // 获取所有半选中节点key 这里key是菜单id
  const halfKeys = tree.getHalfCheckedKeys();
  const selectedKeys = [...halfKeys, ...keys];
  handleRoleWithMenu(selectedKeys as number[], role.id);
};

// 根据权限列表 设置权限选中
const setAccessTreeChecked = (access: number[]) => {
  (menuTree.value as ElTreeInstance).setCheckedKeys(access, false);
  nextTick(() => {
    checkStrictly.value = false;
  });
};

// 获取当前角色 权限列表
const getRoleAccessList = () => {
  checkStrictly.value = true;
  getRoleAccess(role.id)
    .then((res) => {
      if (res.code === 0) {
        const access = res.data.map((item) => item.access_id);
        // 设置选中权限
        setAccessTreeChecked(access);
      }
    })
    .catch(() => {
      checkStrictly.value = false;
    });
};

// tree 全部选中
const isCheckAll = ref(false);
const handleCheckAll = () => {
  if (!isCheckAll.value) {
    (menuTree.value as ElTreeInstance).setCheckedNodes(
      treeData.value as any,
      false
    );
  } else {
    (menuTree.value as ElTreeInstance).setCheckedNodes([], false);
  }
  isCheckAll.value = !isCheckAll.value;
};

onMounted(() => {
  getRoleAccessList();
});
</script>
```

## 37. 权限指令

### 37.1 创建指令

src/directive/permission/permission.ts

```ts
import { ObjectDirective, DirectiveBinding, App } from "vue";
import { useUserStore } from "@/stores/user";
export interface IDirectiveOptionsWithInstall extends ObjectDirective {
  install?: (app: App) => void;
}
const checkPermission = (el: HTMLElement, binding: DirectiveBinding) => {
  const { value } = binding;
  const store = useUserStore();
  const roles = computed(() => store.state.roles?.map((item) => item.name));
  if (value && Array.isArray(value)) {
    if (value.length > 0) {
      const permissionRoles = value;
      const hasPermission = roles.value?.some((role: string) =>
        permissionRoles.includes(role)
      );
      if (!hasPermission) {
        // 指令权限缺点 移除Dom后 无法恢复
        return el.parentNode?.removeChild(el);
      }
    } else {
      // eslint-disable-next-line
      throw new Error(`need roles! Like v-permission="
['admin','editor']"`);
    }
  }
};
// 默认相当于 mounted and updated
const plugin = (el: HTMLElement, binding: DirectiveBinding) => {
  checkPermission(el, binding);
};
export default plugin as IDirectiveOptionsWithInstall;
```

### 38.2 封装成 vue plugin

src/directive/permission/index.ts

```ts
import { App } from "vue";
import permission from "./permission";
const install = (app: App): void => {
  app.directive("permission", permission);
};
export default install;
```

### 38.3 入口注册指令

src/main.ts

```ts
// 权限指令
import permissionDirective from "./directive/permission/index";
import "./permission";
const pinia = createPinia();
const app = createApp(App);
pinia.use(piniaPluginPersistedstate);
app.use(pinia);
// 安装element-plus插件
app.use(installElementPlus);
app.use(permissionDirective); // 注册权限指令
```

## 39. 个人中心

### 39.1 个人中心页

src/views/profile/index.vue

```vue
<template>
  <div class="profile-container">
    <el-card>
      <template #header>
        <div class="card-header">
          <span>关于我</span>
        </div>
      </template>
      <div class="profile" v-if="userInfo">
        <div class="avatar">
          <img :src="avatar" alt="" />
        </div>
        <h2>用户名：{{ userInfo.username }}</h2>
        <h3>用户角色：{{ roleNames }}</h3>
        <div v-if="userInfo.description">
          <span>个人说明</span>
          <p>{{ userInfo.description }}</p>
        </div>
      </div>
    </el-card>
  </div>
</template>
<script lang="ts" setup>
import defaultAvatar from "@/assets/vue.svg";
import { useUserStore } from "@/stores/user";
const store = useUserStore();
const userInfo = computed(() => store.state.userInfo);
const roleNames = computed(() => store.state.roles?.map((item) => item.name));
const avatar = computed(() => userInfo?.value?.avatar || defaultAvatar);
</script>
<style lang="scss" scoped>
.profile-container {
  width: 500px;
  margin: 10px auto;
  .profile {
    text-align: center;
    .avatar {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      margin: 10px auto;
      img {
        width: 100%;
        height: 100%;
      }
    }
  }
}
</style>
```

### 39.2 路由注册

src/router/index.ts

```ts
const constantRoutes: Array<RouteRecordRaw> = [
  // ...
  {
    path: "/profile",
    component: Layout,
    redirect: "/profile/index",
    name: "ProfileLayout",
    children: [
      {
        path: "index",
        name: "Profile",
        component: () => import("@/views/profile/index.vue"),
        meta: {
          hidden: true,
          title: "个人中心",
        },
      },
    ],
  },
];
```

### 39.3 修改头像下拉选项

src/components/Avatar/index.vue

```vue
<template>
  <el-dropdown class="avatar-container">
    <div class="avatar-wrapper">
      <img :src="avatar" class="user-avatar" />
      <i class="el-icon-caret-bottom" />
    </div>
    <template #dropdown>
      <el-dropdown-menu>
        <el-dropdown-item v-if="username">
          <span style="display: block" :style="{ fontWeight: '500' }"
            >用户名：{{ username }}</span
          >
        </el-dropdown-item>
        <router-link to="/">
          <el-dropdown-item>首页</el-dropdown-item>
        </router-link>
        <router-link to="/profile/index">
          <el-dropdown-item>个人中心</el-dropdown-item>
        </router-link>
        <el-dropdown-item divided @click="logout">
          <span style="display: block">退出登录</span>
        </el-dropdown-item>
      </el-dropdown-menu>
    </template>
  </el-dropdown>
</template>
<script lang="ts" setup>
import defaultAvatar from "@/assets/vue.svg";
import { useUserStore } from "@/stores/user";
const store = useUserStore();
const { proxy } = getCurrentInstance()!;
const logout = () => {
  store.logout();
  proxy?.$message.success("退出登录");
  window.location.reload();
};
const userInfo = computed(() => store.state.userInfo);
const avatar = computed(() => userInfo.value?.avatar || defaultAvatar);
const username = computed(() => userInfo.value?.username || "");
</script>
<style lang="scss" scoped>
.avatar-container {
  margin-right: 30px;
  .avatar-wrapper {
    margin-top: 5px;
    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      cursor: pointer;
    }
    .el-icon-caret-bottom {
      cursor: pointer;
      font-size: 12px;
    }
  }
}
</style>
```