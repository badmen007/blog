## 7. 路由菜单递归

### 7.1 导入路由表

> sidebar 组件导入路由表，根据 routes 循环 SidebarItem 组件

```vue
<template>
  <h4 @click="isCollapse = !isCollapse">展收测试</h4>
  <el-menu
    class="sidebar-container-menu"
    mode="vertical"
    :default-active="activeMenu"
    :background-color="scssVariables.menuBg"
    :text-color="scssVariables.menuText"
    :active-text-color="scssVariables.menuActiveText"
    :collapse="isCollapse"
    :collapse-transition="true"
  >
    <!-- 循环sidebar-item组件 -->
    <sidebar-item
      v-for="route in menuRoutes"
      :key="route.path"
      :item="route"
      :base-path="route.path"
    />
  </el-menu>
</template>
<script lang="ts" setup>
import scssVariables from "@/styles/variables.module.scss";
import SidebarItem from "./SidebarItem.vue";
// 导入路由表
import { routes } from "@/router";
// 渲染路由
const menuRoutes = computed(() => routes);
</script>
```

### 7.2 实现 SidebarItem 组件

```vue
<template>
  <div class="sidebar-item-container" v-if="!item.meta || !item.meta.hidden">
    <!-- 如果有一个孩子，或者没孩子，或者有一个孩子但是被hidden了 -->
    <template v-if="theOnlyOneChildRoute">
      <!-- 如果没有meta属性意味着不必渲染了 -->
      <el-menu-item
        :index="resolvePath(theOnlyOneChildRoute.path)"
        v-if="theOnlyOneChildRoute.meta"
      >
        <el-icon v-if="icon">
          <svg-icon class="menu-icon" :icon-class="icon"></svg-icon>
        </el-icon>
        <template #title>
          <span>{{ theOnlyOneChildRoute.meta?.title }}</span>
        </template>
      </el-menu-item>
    </template>
    <!-- 多个子路由时 -->
    <el-sub-menu v-else :index="resolvePath(item.path)" popper-appendto-body>
      <template #title>
        <el-icon v-if="item.meta?.icon">
          <svg-icon class="menu-icon" :icon-class="item.meta.icon"> </svg-icon>
        </el-icon>
        <span class="submenu-title">{{ item.meta?.title }}</span>
      </template>
      <sidebar-item
        v-for="child in item.children"
        :key="child.path"
        :is-nest="true"
        :item="child"
        :base-path="resolvePath(child.path)"
      >
      </sidebar-item>
    </el-sub-menu>
  </div>
</template>
<script setup lang="ts">
import type { PropType } from "vue";
import type { RouteRecordRaw } from "vue-router";
import path from "path-browserify";

const props = defineProps({
  item: {
    type: Object as PropType<RouteRecordRaw>,
    required: true,
  },
  basePath: {
    type: String,
    required: true,
  },
});
// 看看要渲染的儿子有多少
const showingChildNumber = computed(() => {
  const children = (props.item.children || []).filter((child) => {
    if (child.meta && child.meta.hidden) return false;
    return true;
  });
  return children.length;
});
const { item } = toRefs(props);
// 只处理一个儿子的情况
const theOnlyOneChildRoute = computed(() => {
  // 多个children时 直接return null 多children需要用el-submenu来渲染并递归
  if (showingChildNumber.value > 1) {
    return null;
  }
  // 只有一个子路由 还要筛选路由meta里有无hidden属性 hidden：true则过滤出去 不用管;
  // 路由meta里我们会配置hidden属性表示不渲染成菜单，比如login 401 404页面是不渲染成菜单的;
  if (item.value.children) {
    for (const child of item.value.children) {
      if (!child.meta || !child.meta.hidden) {
        return child;
      }
    }
  }
  // showingChildNumber === 0 无可渲染的子路由 （可能有子路由 hidden属性为true）
  // 无可渲染chiildren时 把当前路由item作为仅有的子路由渲染
  return {
    ...props.item,
    path: "",
  };
});

// menu icon
const icon = computed(() => {
  // 子路由 如果没有icon就用父路由的
  return (
    theOnlyOneChildRoute.value?.meta?.icon ||
    (props.item.meta && props.item.meta.icon)
  );
});

// 利用path.resolve 根据父路径+子路径 解析成正确路径 子路径可能是相对的
// resolvePath在模板中使用
const resolvePath = (childPath: string) => {
  return path.resolve(props.basePath, childPath);
};
</script>
```

> 安装 pnpm i path-browserify @types/path-browserify

### 7.3 sidebar css 样式调整

src/styles/sidebar.scss

```scss
#app {
  .sidebar-container {
    height: 100%;
    background-color: $menuBg;
    // menu未收起时样式
    &-menu:not(.el-menu--collapse) {
      width: $sideBarWidth;
    }
    .el-menu {
      border: none;
    }

    // 菜单收起时的样式调整
    .el-menu--collapse {
      // 隐藏submenu title
      .submenu-title {
        display: none;
      }
    }
    .el-submenu {
      .el-menu {
        .el-menu-item {
          background-color: $subMenuBg !important;
          &:hover {
            background-color: $subMenuHover !important;
          }
        }
      }
    }
  }
}
```

## 8. 菜单外链处理

### 8.1 创建 SidebarItemLink 组件

在这个组件里来判断 是否是带协议链接 如果是带协议链接 menu-item 里，就用 a 标签渲染
否则用 router-link 渲染 （注意 el-menu 路由模式不必开启 无需增添 router 属性）

> 用到了 component 动态组件 并以插槽形式包裹 SIdebarItem 组件

src/layout/components/Sidebar/SidebarItemLink.vue

```vue
<template>
  <component :is="type" v-bind="linkProps">
    <slot />
  </component>
</template>

<script lang="ts" setup>
import { isExternal } from "@/utils/validate";

// 针对路径是外链 就渲染成a标签 如果是正常路径 就渲染成router-link

const props = defineProps({
  to: {
    type: String,
    required: true,
  },
});

// 判断接受的路径 是不外链
const isExt = computed(() => isExternal(props.to));
const type = computed(() => {
  if (isExt.value) {
    return "a";
  }
  return "router-link";
});

const linkProps = computed(() => {
  if (isExt.value) {
    return {
      // a标签的原生属性
      href: props.to,
      target: "_blank",
      ref: "noopener",
    };
  }
  return {
    // router-link只需要一个to props
    to: props.to,
  };
});
</script>
```

### 8.2 SidebarItem 中使用 SidebarItemLink 组件

src/layout/components/Sidebar/SidebarItem.vue

```vue
<template>
  <div class="sidebar-item-container" v-if="!item.meta || !item.meta.hidden">
    <template v-if="theOnlyOneChildRoute">
      <sidebar-item-link
        :to="resolvePath(theOnlyOneChildRoute.path)"
        v-if="theOnlyOneChildRoute.meta"
      >
        <el-menu-item
          :index="resolvePath(theOnlyOneChildRoute.path)"
          v-if="theOnlyOneChildRoute.meta"
        >
          <el-icon>
            <svg-icon class="menu-icon" :icon-class="icon"></svg-icon>
          </el-icon>
          <template #title>
            <span>{{ theOnlyOneChildRoute.meta?.title }}</span>
          </template>
        </el-menu-item>
      </sidebar-item-link>
    </template>
    ...
  </div>
</template>
```

```ts
// 外链的话 直接返回
const resolvePath = (childPath: string) => {
  if (isExternal(childPath)) {
    return childPath;
  }
  return path.resolve(props.basePath, childPath);
};
```

### 8.3 添加外链路由

src/router.index.ts

```ts
export const asyncRoutes: Array<RouteRecordRaw> = [
  ...{
    // 外链路由
    path: "/external-link",
    component: Layout,
    children: [
      {
        path: "http://www.zhufengpeixun.com/",
        redirect: "/",
        meta: {
          title: "External Link",
          icon: "link",
        },
      },
    ],
  },
];
```

### 8.4 去掉 a 标签默认样式

src/styles/index.scss

```scss
// a标签默认样式调整
a:focus,
a:active {
  outline: none;
}
a,
a:focus,
a:hover {
  cursor: pointer;
  color: inherit;
  text-decoration: none;
}
```

## 9. 菜单支持路由 hidden 属性

> 主要是控制某些路由不用渲染成菜单，比如 login 404 401 等路由

默认 hidden 就是 false 显示在菜单

### 9.1 路由表里设置 hidden

```ts
{
    path: '/system',
    component: Layout,
    redirect: '/system/user',
    meta: {
      title: 'System',
      icon: 'lock'
    },
    children: [
      {
        path: 'menu',
        component: () =>
          import(/* webpackChunkName: "menu" */ '@/views/system/menu.vue'),
        meta: {
          title: 'Menu Management',
          icon: 'list',
          hidden: true
        }
      },
      {
        path: 'role',
        component: () =>
          import(/* webpackChunkName: "role" */ '@/views/system/role.vue'),
        meta: {
          title: 'Role Management',
          icon: 'list'
        }
      },
      {
        path: 'user',
        component: () =>
          import(/* webpackChunkName: "user" */ '@/views/system/user.vue'),
        meta: {
          title: 'User Management',
          icon: 'list'
        }
      }
    ]
  },
```

### 9.2 SidebarItem 组件修改

主要是在渲染菜单项前 根据 route.meta.hidden 属性进行筛选，将 hidden 为 true 的筛选出
去 不进行菜单渲染

```ts
const theOnlyOneChildRoute = computed(() => {
  ...
  return {
    ...props.item,
    path: '',
    noShowingChildren: true // 没有可渲染的children
  }
})
```

```vue
<template>
  <div class="sidebar-item-container" v-if="!item.meta || !item.meta.hidden">
    <!-- 就是这里添加了判断条件 -->
    <template
      v-if="
        theOnlyOneChildRoute &&
        (!theOnlyOneChildRoute.children ||
          theOnlyOneChildRoute.noShowingChildren)
      "
    >
      ...
    </template>
    <!-- 多个子路由 -->
    ...
  </div>
</template>
```