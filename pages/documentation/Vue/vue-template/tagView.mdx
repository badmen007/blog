## 17. 标签导航基本功能

### 17.1 定义 store

src/stores/tagsView.ts

```ts
import { defineStore } from "pinia";
import { RouteLocationNormalizedLoaded } from "vue-router";
export const useTagsView = defineStore("tag", () => {
  const visitedViews = ref<RouteLocationNormalizedLoaded[]>([]);
  // 添加视图
  const addView = (view: RouteLocationNormalizedLoaded) => {
    // 去重
    if (visitedViews.value.some((v) => v.path === view.path)) return;
    // 没有title的处理
    visitedViews.value.push(
      Object.assign({}, view, {
        title: view.meta?.title || "tag-name",
      })
    );
  };
  // 删除视图
  const delView = (view: RouteLocationNormalizedLoaded) => {
    const i = visitedViews.value.indexOf(view);
    if (i > -1) {
      visitedViews.value.splice(i, 1);
    }
  };
  return { visitedViews, addView, delView };
});
```

### 17.2 创建 TagsView 组件

src/layout/components/TagsView/index.vue

```vue
<template>
  <div class="tags-view-container">
    <div class="tags-view-wrapper">
      <!-- 一个个tag view就是router-link -->
      <router-link
        class="tags-view-item"
        :class="{
          active: isActive(tag),
        }"
        v-for="(tag, index) in visitedViews"
        :key="index"
        :to="{ path: tag.path, query: tag.query }"
      >
        <span>{{ tag.meta.title }}</span>
        <el-icon class="icon-close">
          <CloseBold @click.prevent.stop="closeSelectedTag(tag)" />
        </el-icon>
      </router-link>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { useTagsView } from "@/stores/tagsView";
import { storeToRefs } from "pinia";
import { RouteLocationNormalized } from "vue-router";
import { CloseBold } from "@element-plus/icons-vue";
const store = useTagsView();
const { visitedViews } = storeToRefs(store);
const route = useRoute();
// 从store里获取 可显示的tags view
// 添加tag
const addTags = () => {
  const { name } = route;
  if (name) {
    store.addView(route);
  }
};
watch(
  () => route.path,
  () => {
    addTags();
  },
  { immediate: true }
);
// 是否是当前应该激活的tag
const isActive = (tag: RouteLocationNormalized) => {
  return tag.path === route.path;
};

// 关闭当前右键的tag路由
const closeSelectedTag = (view: RouteLocationNormalized) => {
  store.delView(view);
};
</script>
<style lang="scss" scoped>
.tags-view-container {
  width: 100%;
  height: 34px;
  background: #fff;
  border-bottom: 1px solid #d8dce5;
  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.12), 0 0 3px 0 rgba(0, 0, 0, 0.04);
  .tags-view-wrapper {
    .tags-view-item {
      display: inline-block;
      height: 26px;
      line-height: 26px;
      border: 1px solid #d8dce5;
      background: #fff;
      color: #495060;
      padding: 0 8px;
      box-sizing: border-box;
      font-size: 12px;
      margin-left: 5px;
      margin-top: 4px;
      &:first-of-type {
        margin-left: 15px;
      }
      &:last-of-type {
        margin-right: 15px;
      }
      &.active {
        background-color: #42b983;
        color: #fff;
        border-color: #42b983;
        &::before {
          position: relative;
          display: inline-block;
          content: "";
          width: 8px;
          height: 8px;
          border-radius: 50%;
          margin-right: 5px;
          background: #fff;
        }
      }
    }
    span {
      vertical-align: middle;
    }
  }
  .icon-close {
    width: 16px;
    height: 16px;
    vertical-align: middle;
    position: relative;
    left: 2px;
    border-radius: 50%;
    text-align: center;
    transition: all 0.3s cubic-bezier(0.645, 0.045, 0.355, 1);
    transform-origin: 100% 50%;
    &:before {
      transform: scale(0.6);
      display: inline-block;
      vertical-align: -1px;
    }
    &:hover {
      background-color: #b4bccc;
      color: #fff;
    }
  }
}
</style>
```

> 这里需要安装 pnpm i @element-plus/icons-vue 图标库

src/layout/index.vue 中引入 tagsView 组件

```vue
<template>
  <div class="app-wrapper">
    <div class="sidebar-container">
      <Sidebar></Sidebar>
    </div>
    <div class="main-container">
      <div class="header">
        <navbar></navbar>
        <!-- 加了这里 -->
        <tags-view></tags-view>
      </div>
      <app-main></app-main>
    </div>
  </div>
</template>
```

修改 navbar 样式

src/layout/components/Navbar.vue

```scss
.navbar {
  display: flex;
  background: #fff;
  border-bottom: 1px solid rgba(0, 21, 41, 0.08);
  box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);
}
```

## 18. 标签导航删除选中处理

> 当删除的是激活状态 tag 时，我就让剩下集合中最后一个为激活态并跳转到对应路由

### 18.1 修改 tagviews 组件

> 删除后 调用 toLastView 方法，从剩下集合中得到最后一个路由 tag 触发路由跳转 即可

```ts
// 关闭当前右键的tag路由
const closeSelectedTag = (view: RouteLocationNormalized) => {
  store.delView(view);
  if (isActive(view)) {
    toLastView(visitedViews.value, view);
  }
};

const router = useRouter();
const toLastView = (
  visitedViews: RouteLocationNormalized[],
  view: RouteLocationNormalized
) => {
  // 得到集合中最后一项的tag view 可能没有
  const lastView = visitedViews[visitedViews.length - 1];
  if (lastView) {
    router.push(lastView.path);
  } else {
    // 集合中都没有tag view时
    // 如果刚刚删除的正是Dashboard 就重定向回Dashboard（首页）
    if (view.name === "Dashboard") {
      router.push({ path: view.path });
    } else {
      // tag都没有了 删除的也不是Dashboard 只能跳转首页
      router.push("/");
    }
  }
};
```

## 19. 标签导航支持固定 tag

> 通过路由 meta 里添加 affix 属性为 true，就让当前路由 tag 始终固定在标签导航

### 19.1 Dashboard 路由 meta 中添加 affix: true

### 19.2 修改 tagsView 组件

在页面最开始加载的时候就要筛选出有 affix 的路由，渲染到页面上，并且不显示关闭的 icon

src/layout/components/TagsView/index.vue

```vue
<template>
  <el-icon class="icon-close" v-if="!isAffix(tag)">
    <CloseBold @click.prevent.stop="closeSelectedTag(tag)" />
  </el-icon>
</template>
<script lang="ts" setup>
import { RouteLocationNormalized, RouteRecordRaw } from "vue-router";
import path from "path-browserify";
import { routes } from "@/router";
const filterAffixTags = (routes: RouteRecordRaw[], basePath = "/") => {
  let tags: RouteLocationNormalized[] = [];
  routes.forEach((route) => {
    if (route.meta && route.meta.affix) {
      // 把路由路径解析成完整路径，路由可能是相对路径
      const tagPath = path.resolve(basePath, route.path);
      tags.push({
        name: route.name,
        path: tagPath,
        meta: { ...route.meta },
      } as RouteLocationNormalized);
    }
    // 深度优先遍历 子路由（子路由路径可能相对于route.path父路由路径）
    if (route.children) {
      const childTags = filterAffixTags(route.children, route.path);
      if (childTags.length) {
        tags = [...tags, ...childTags];
      }
    }
  });
  return tags;
};
const initTags = () => {
  const affixTags = filterAffixTags(routes);
  for (const tag of affixTags) {
    if (tag.name) {
      store.addView(tag);
    }
  }
};
const isAffix = (tag: RouteLocationNormalized) => {
  return tag.meta && tag.meta.affix;
};
onMounted(() => {
  initTags();
});
</script>
```

## 20. 标签导航支持横向滑动

> 当标签导航太多时，超出页面宽度时，可以左右横向滑动

### 20.1 添加 scrollbar 组件

创建 ScrollPanel 组件

src/layout/components/TagsView/ScrollPanel.vue

```vue
<template>
  <el-scrollbar wrap-class="scroll-wrapper">
    <slot />
  </el-scrollbar>
</template>
<style lang="scss">
.scroll-wrapper {
  position: relative;
  width: 100%;
  white-space: nowrap;
}
</style>
```

### 20.2 修改 tagsview

用 scrollpanel 组件包裹 tagsview 组件

```vue
<template>
  <div class="tags-view-container">
    +
    <scroll-panel>
      <div class="tags-view-wrapper">
        <!-- 一个个tag view就是router-link -->
        <router-link
          class="tags-view-item"
          :class="{
            active: isActive(tag),
          }"
          v-for="(tag, index) in visitedViews"
          :key="index"
          :to="{ path: tag.path, query: tag.query }"
        >
          <span>{{ tag.meta.title }}</span>
          <el-icon class="icon-close" v-if="!isAffix(tag)">
            <CloseBold @click.prevent.stop="closeSelectedTag(tag)" />
          </el-icon>
        </router-link>
      </div>
      +
    </scroll-panel>
  </div>
</template>
<style lang="scss" scoped>
.tags-view-container {
 width: 100%;
 height: 34px;
 background: #fff;
 border-bottom: 1px solid #d8dce5;
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.12), 0 0 3px 0 rgba(0, 0, 0,
0.04);
+ overflow: hidden;
}
</style>
```

### 20.3 注意使用标签导航

> 使用标签导航的路由 必须要 name 属性 因为方便我们根据 name 进行路由筛选和缓存 keep-alive

给 `menu` `role` `user` 添加 name 属性，因为 tagView 里面是根据 name 筛选的

```ts
children: [
  {
    path: "menu",
    name: "Menu Management",
    component: () =>
      import(/* webpackChunkName: "menu" */ "@/views/system/menu.vue"),
    meta: {
      title: "Menu Management",
      icon: "list",
      hidden: true,
    },
  },
  {
    path: "role",
    name: "Role Management",
    component: () =>
      import(/* webpackChunkName: "role" */ "@/views/system/role.vue"),
    meta: {
      title: "Role Management",
      icon: "list",
    },
  },
  {
    path: "user",
    name: "User Management",
    component: () =>
      import(/* webpackChunkName: "user" */ "@/views/system/user.vue"),
    meta: {
      title: "User Management",
      icon: "list",
    },
  },
];
```

## 21. 标签导航支持对应路由缓存

### 21.1 标签导航支持对应路由缓存

:::tip
再添加标签导航时，同时也判断该路由要不要缓存，要缓存就根据路由配置的 name 属
性进行缓存（路由组件的 name 要与路由配置的 name 一致）再添加到 keep-alive
inludes 的缓存列表中。
（keep-alive 内部是根据组件的 name 进行缓存，我们添加到 cachedViews 缓存列表的
name 是从每条路由配置的 name 取得值，所以路由组件和路由配置中必须要有一致的
name 属性。）
:::

src/stores/tagsView.ts

```ts
import { defineStore } from "pinia";
import { RouteLocationNormalizedLoaded, RouteRecordName } from "vue-router";
export const useTagsView = defineStore("tag", () => {
  const visitedViews = ref<RouteLocationNormalizedLoaded[]>([]);
  // 添加视图
  const addView = (view: RouteLocationNormalizedLoaded) => {
    // 去重
    if (visitedViews.value.some((v) => v.path === view.path)) return;
    // 没有title的处理
    visitedViews.value.push(
      Object.assign({}, view, {
        title: view.meta?.title || "tag-name",
      })
    );
    addCachedView(view);
  };
  // 删除视图
  const delView = (view: RouteLocationNormalizedLoaded) => {
    const i = visitedViews.value.indexOf(view);
    if (i > -1) {
      visitedViews.value.splice(i, 1);
    }
    delCachedView(view);
  };

  const cachedViews = ref<RouteRecordName[]>([]);

  const addCachedView = (view: RouteLocationNormalizedLoaded) => {
    if (cachedViews.value.includes(view.name!)) return;
    if (!view.meta.noCache) {
      cachedViews.value.push(view.name!);
    }
  };

  const delCachedView = (view: RouteLocationNormalizedLoaded) => {
    // 删除缓存
    const index = cachedViews.value.indexOf(view.name!);
    index > -1 && cachedViews.value.splice(index, 1);
  };

  return { visitedViews, addView, delView, cachedViews };
});
```

### 21.2 AppMain 中根据 store 中 cachedViews 列表进行缓存

> 给 keep-alive 添加 includes 列表，从 store 中获取 cachedViews 缓存列表作为 includes 列表

src/layout/components/AppMain.vue

```vue
<template>
  <div class="app-main">
    <router-view v-slot="{ Component }">
      <transition name="fade-transform" mode="out-in">
        <keep-alive :include="includes">
          <component :is="Component" :key="route.path" />
        </keep-alive>
      </transition>
    </router-view>
  </div>
</template>

<script lang="ts" setup>
import { useRoute } from "vue-router";
import { useTagsView } from "@/stores/tagsView";
import { storeToRefs } from "pinia";
const route = useRoute();
const store = useTagsView();

const { cachedViews } = storeToRefs(store);
const includes = computed(() => cachedViews.value as string[]);
</script>
```

### 21.3 给组件添加 name 属性

vite.config.ts

> 安装插件 unplugin-vue-define-options/vite 定义 name 属性

```bash
pnpm install unplugin-vue-define-options -D
```

```ts
import DefineOptions from "unplugin-vue-define-options/vite";
export default defineConfig({
  plugins: [vue(), DefineOptions()],
});
```

```vue
<template>
  <div>
    <el-button>按钮</el-button>
    <input type="text" />
  </div>
</template>
<script setup lang="ts">
defineOptions({ name: "Dashboard" });
</script>
```

解决 ts 报错问题 tsconfig.json

```json
{
  "compilerOptions": {
    // ...
    "types": [
      "element-plus/global",
      "unplugin-vue-define-options/macros-global"
    ]
  }
}
```

解决 eslint 报错问题 .eslintrc.cjs

```js
module.exports = {
  // ...
  globals: {
    defineOptions: "readonly",
  },
};
```
